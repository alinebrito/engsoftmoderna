<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Marco Tulio Valente" />
  <title>Cap. 8: Testes – Engenharia de Software Moderna</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    q { quotes: "“" "”" "‘" "’"; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <script>
     (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

     ga('create', 'UA-8249107-3', 'auto');
     ga('send', 'pageview');
  </script>


  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mini.css/3.0.1/mini-default.min.css">

  <style>
  body {
    background-color: #FCFCFC;
    foreground-color: black;
  }
  </style>
</head>
<body>
<div class="container">
<div class="row cols-sm-12 col-md-8 col-lg-6">
<div class="col-md-offset-1 col-lg-offset-3">

<p>
<a href="https://engsoftmoderna.info">Índice</a>
</p>
<header id="title-block-header">
<h1 class="title">Engenharia de Software Moderna</h1>
<p class="author">Marco Tulio Valente</p>
</header>
<h1 data-number="1" id="testes" data-number="1"><span class="header-section-number">8</span> Testes</h1>
<blockquote>
<p><em>Code without tests is bad code.</em> – Michael Feathers</p>
</blockquote>
<p>Este capítulo inicia com uma introdução a testes, na qual usamos uma pirâmide para classificar os principais tipos de testes, de acordo com a sua granularidade e frequência. Também esclarecemos que o nosso foco no capítulo são testes de unidade. Assim, começamos com uma seção sobre conceitos e funcionamento básico desse tipo de teste (Seção 8.2). Em seguida, tratamos de aspectos avançados e complementares, ainda sobre testes de unidade, incluindo princípios para escrita de tais testes (Seção 8.3), cobertura de testes (Seção 8.4), projeto de software para facilitar a implementação de testes de unidade (Seção 8.5) e objetos mocks, os quais são usados para facilitar a implementação de testes de unidade (Seção 8.6). Na Seção 8.7, apresentamos o conceito de Desenvolvimento Dirigido por Testes (ou <em>Test-Driven Development</em>, TDD). Em seguida, tratamos dos testes da parte de cima da pirâmide de testes, ou seja, Testes de Integração (Seção 8.8) e Testes de Sistemas (Seção 8.9). Para fechar o capítulo, a Seção 8.10 cobre de forma rápida outros tipos de testes, tais como: testes caixa preta e caixa branca, testes de aceitação e testes de requisitos não-funcionais.</p>
<h2 data-number="1.1" id="introdução" data-number="1.1"><span class="header-section-number">8.1</span> Introdução</h2>
<p>Software é uma das construções humanas mais complexas, como discutimos na Introdução deste livro. Portanto, é compreensível que sistemas de software estejam sujeitos aos mais variados tipos de erros e inconsistências. Para evitar que tais erros cheguem aos usuários finais e causem prejuízos de valor incalculável, é fundamental introduzir atividades de teste em projetos de desenvolvimento de software. De fato, testes é uma das práticas de programação mais valorizadas hoje em dia, em qualquer tipo de software. É também uma das práticas que sofreram mais transformações nos anos recentes.</p>
<p>Quando o desenvolvimento era em cascata, os testes ocorriam em uma fase separada, após as fases de levantamento de requisitos, análise, projeto e codificação. Além disso, existia uma equipe separada de testes, responsável por verificar se a implementação atendia aos requisitos do sistema. Para garantir isso, frequentemente os testes eram manuais, isto é, uma pessoa usava o sistema, informava dados de entrada e verificava se as saídas eram aquelas esperadas. Assim, o objetivo de tais testes era apenas detectar bugs, antes que o sistema entrasse em produção.</p>
<p>Com métodos ágeis, a prática de testes de software foi profundamente reformulada:</p>
<ul>
<li><p>Grande parte dos testes passou a ser automatizada, isto é, além de implementar as classes de um sistema, os desenvolvedores passaram a implementar também código para testar tais classes. Assim, os programas tornaram-se <strong>auto-testáveis</strong>.</p></li>
<li><p>Testes não são mais implementados após todas as classes de um sistema ficarem prontas. Muitas vezes, eles são implementados até mesmo antes dessas classes.</p></li>
<li><p>Não existem mais grandes equipes de testes — ou elas são responsáveis por testes específicos. Em vez disso, o desenvolvedor que implementa uma classe também deve implementar os seus testes.</p></li>
<li><p>Testes não são mais um instrumento exclusivo para detecção de bugs. Claro, isso continua sendo importante, mas testes ganharam novas funções, como garantir que uma classe continuará funcionando após um bug ser corrigido em uma outra parte do sistema. E testes são também usados como documentação para o código de produção.</p></li>
</ul>
<p>Essas transformações tornaram testes uma das práticas de programação mais valorizadas em desenvolvimento moderno de software. É nesse contexto que devemos entender a frase de Michael Feathers que abre esse capítulo: se um código não é acompanhado de testes, ele pode ser considerado de baixa qualidade ou até mesmo um código legado<em>.</em></p>
<p>Neste capítulo, vamos focar em <strong>testes automatizados</strong>, pois testes manuais dão muito trabalho, são demorados e caros. Pior ainda, eles devem ser repetidos toda vez que o sistema sofrer uma modificação.</p>
<p>Uma forma interessante de classificar testes automatizados é por meio de uma <strong>pirâmide de testes</strong>, originalmente proposta por Mike Cohn (<a href="https://dl.acm.org/citation.cfm?id=1667109">link</a>). Como mostra a próxima figura, essa pirâmide particiona os testes de acordo com sua granularidade.</p>
<figure>
<img src="figs/cap8/piramide-testes.svg" style="width:70.0%" alt="" /><figcaption>Pirâmide de testes</figcaption>
</figure>
<p>Particularmente, os testes são divididos em três grupos. <strong>Testes de unidade</strong> verificam automaticamente pequenas partes de um código, normalmente uma classe apenas (acompanhe também pelas figuras da próxma página). Eles formam a base da pirâmide, ou seja, a maior parte dos testes estão nessa categoria. Testes de unidade são simples, mais fáceis de implementar e executam rapidamente. No próximo nível, temos <strong>testes de integração</strong> ou <strong>testes de serviços</strong>, que verificam uma funcionalidade ou transação completa de um sistema. Logo, são testes que usam diversas classes, de pacotes distintos, e podem ainda testar componentes externos, como bancos de dados. Testes de integração demandam mais esforço para serem implementados e executam de forma mais lenta. Por fim, no topo da pirâmide, temos os <strong>testes de sistema</strong>, também chamados de <strong>testes de interface com o usuário</strong>. Eles simulam, da forma mais fiel possível, uma sessão de uso do sistema por um usuário real. Como são testes de ponta a ponta (<em>end-to-end</em>), eles são mais caros, mais lentos e menos numerosos. Testes de interface costumam ser também frágeis, isto é, mínimas alterações nos componentes da interface podem demandar modificações nesses testes.</p>
<figure>
<img src="figs/cap8/teste-unidade.svg" style="width:25.0%" alt="" /><figcaption>Escopo de testes de unidade</figcaption>
</figure>
<figure>
<img src="figs/cap8/teste-integracao.svg" style="width:25.0%" alt="" /><figcaption>Escopo de testes de integração</figcaption>
</figure>
<figure>
<img src="figs/cap8/teste-sistema.svg" style="width:25.0%" alt="" /><figcaption>Escopo de testes de sistema</figcaption>
</figure>
<p>Uma recomendação genérica é que esses três testes sejam implementados na seguinte proporção: 70% como testes de unidades; 20% como testes de serviços e 10% como testes de sistema (<a href="https://dl.acm.org/citation.cfm?id=2207802">link</a>, Capítulo 3).</p>
<p>Neste capítulo, vamos estudar os três tipos de testes da pirâmide de testes. O espaço que dedicaremos a cada teste também será compatível com seu espaço na pirâmide. Ou seja, falaremos mais de testes de unidade do que de testes de sistema, pois os primeiros são muito mais comuns. Antes de começar de fato, gostaríamos de relembrar alguns conceitos que apresentamos na Introdução. Diz-se que um código possui um <strong>defeito</strong> — ou um <strong>bug</strong>, de modo mais informal — quando ele não está de acordo com a sua especificação. Se um código com defeito for executado e levar o programa a apresentar um resultado ou comportamento incorreto, dizemos que ocorreu uma <strong>falha</strong> (<em>failure</em>).</p>
<h2 data-number="1.2" id="testes-de-unidade" data-number="1.2"><span class="header-section-number">8.2</span> Testes de Unidade</h2>
<p>Testes de unidade são testes automatizados de pequenas unidades de código, normalmente classes, as quais são testadas de forma isolada do restante do sistema. Um teste de unidade é um programa que chama métodos de uma classe e verifica se eles retornam os resultados esperados. Assim, quando se usa testes de unidades, o código de um sistema pode ser dividido em dois grupos: um conjunto de classes — que implementam os requisitos do sistema — e um conjunto de testes, conforme ilustrado na próxima figura.</p>
<figure>
<img src="figs/cap8/testes-classes-unidade.svg" style="width:55.0%" alt="" /><figcaption>Correspondência entre classes e testes</figcaption>
</figure>
<p>A figura mostra um sistema com <em>n</em> classes e <em>m</em> testes. Como pode ser observado, não existe uma correspondência de 1 para 1 entre classes e testes. Por exemplo, uma classe pode ter mais de um teste. É o caso da classe C1, que é testada por T1 e T2. Provavelmente, isso ocorre porque C1 é uma classe importante, que precisa ser testada em diferentes contextos. Por outro lado, C2 não possui testes, ou porque os desenvolvedores esqueceram de implementar ou porque ela é uma classe menos importante.</p>
<p>Testes de unidade são implementados usando-se frameworks construídos especificamente para esse fim. Os mais conhecidos são chamados de frameworks <strong>xUnit</strong>, onde o <em>x</em> designa a linguagem usada na implementação dos testes. O primeiro desses frameworks — chamado sUnit — foi implementado por Kent Beck no final da década de 80 para Smalltalk. Neste capítulo, nossos testes serão implementados em Java, usando o <strong>JUnit</strong>. A primeira versão do JUnit foi implementada em conjunto por Kent Beck e Erich Gamma, em 1997, durante uma viagem de avião entre a Suíça e os EUA.</p>
<p>Hoje, existem versões de frameworks xUnit para as principais linguagens de programação. Logo, uma das vantagens de testes de unidade é que os desenvolvedores não precisam aprender uma nova linguagem de programação, pois os testes são implementados na mesma linguagem do sistema que pretende-se testar.</p>
<p>Para explicar os conceitos de testes de unidade, vamos usar a seguinte classe <code>Stack</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">import</span><span class="im"> java.util.ArrayList;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">import</span><span class="im"> java.util.EmptyStackException;</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">public</span> <span class="kw">class</span> <span class="bu">Stack</span>&lt;T&gt; {</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a>  <span class="kw">private</span> <span class="bu">ArrayList</span>&lt;T&gt; elements = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;T&gt;();</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="kw">private</span> <span class="dt">int</span> size = <span class="dv">0</span>;</span>
<span id="cb1-9"><a href="#cb1-9"></a></span>
<span id="cb1-10"><a href="#cb1-10"></a>  <span class="kw">public</span> <span class="dt">int</span> <span class="fu">size</span>() {</span>
<span id="cb1-11"><a href="#cb1-11"></a>    <span class="kw">return</span> size;</span>
<span id="cb1-12"><a href="#cb1-12"></a>  }</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>  <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isEmpty</span>() {</span>
<span id="cb1-15"><a href="#cb1-15"></a>    <span class="kw">return</span> (size == <span class="dv">0</span>);</span>
<span id="cb1-16"><a href="#cb1-16"></a>  }</span>
<span id="cb1-17"><a href="#cb1-17"></a></span>
<span id="cb1-18"><a href="#cb1-18"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">push</span>(T elem) {</span>
<span id="cb1-19"><a href="#cb1-19"></a>    elements.<span class="fu">add</span>(elem);</span>
<span id="cb1-20"><a href="#cb1-20"></a>    size++;</span>
<span id="cb1-21"><a href="#cb1-21"></a>  }</span>
<span id="cb1-22"><a href="#cb1-22"></a></span>
<span id="cb1-23"><a href="#cb1-23"></a>  <span class="kw">public</span> T <span class="fu">pop</span>() <span class="kw">throws</span> <span class="bu">EmptyStackException</span> {</span>
<span id="cb1-24"><a href="#cb1-24"></a>    <span class="kw">if</span> (<span class="fu">isEmpty</span>())</span>
<span id="cb1-25"><a href="#cb1-25"></a>      <span class="kw">throw</span> <span class="kw">new</span> <span class="bu">EmptyStackException</span>();</span>
<span id="cb1-26"><a href="#cb1-26"></a>    T elem = elements.<span class="fu">get</span>(size-<span class="dv">1</span>);</span>
<span id="cb1-27"><a href="#cb1-27"></a>    size--;</span>
<span id="cb1-28"><a href="#cb1-28"></a>    <span class="kw">return</span> elem;</span>
<span id="cb1-29"><a href="#cb1-29"></a>  }</span>
<span id="cb1-30"><a href="#cb1-30"></a></span>
<span id="cb1-31"><a href="#cb1-31"></a>}</span></code></pre></div>
<p>JUnit permite implementar classes que vão testar — de forma automática — classes da aplicação, como a classe <code>Stack</code>. Por convenção, classes de teste têm o mesmo nome das classes testadas, mas com um sufixo <code>Test</code>. Portanto, nossa primeira classe de teste vai se chamar <code>StackTest</code>. Já os métodos de teste começam com o prefixo <code>test</code> e devem, obrigatoriamente, atender às seguintes condições: (1) serem públicos, pois eles serão chamados pelo JUnit; (2) não possuírem parâmetros; (3) possuírem a anotação <code>@Test</code>, a qual identifica métodos que deverão ser executados durante um teste.</p>
<p>Mostramos a seguir nosso primeiro teste de unidade:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">import</span><span class="im"> org.junit.Test;</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.assertTrue;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">public</span> <span class="kw">class</span> StackTest {</span>
<span id="cb2-5"><a href="#cb2-5"></a></span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="at">@Test</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStack</span>() {</span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="bu">Stack</span>&lt;<span class="bu">Integer</span>&gt; stack = <span class="kw">new</span> <span class="bu">Stack</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="dt">boolean</span> empty = stack.<span class="fu">isEmpty</span>();</span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="fu">assertTrue</span>(empty);</span>
<span id="cb2-11"><a href="#cb2-11"></a>  }</span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>}</span></code></pre></div>
<p>Nessa primeira versão, a classe <code>StackTest</code> possui um único método de teste, público, anotado com <code>@Test</code> e chamado <code>testEmptyStack()</code>. Esse método apenas cria uma pilha e testa se ela está vazia.</p>
<p>Métodos de teste têm a seguinte estrutura:</p>
<ul>
<li><p>Primeiro, cria-se o contexto do teste, também chamado de <strong>fixture</strong>. Para isso, deve-se instanciar os objetos que se pretende testar e, se for o caso, inicializá-los. No nosso primeiro exemplo, essa parte do teste inclui apenas a criação de uma pilha de nome <code>stack</code>.</p></li>
<li><p>Em seguida, o teste deve chamar um dos métodos da classe que está sendo testada. No exemplo, chamamos o método <code>isEmpty()</code> e armazenamos o seu resultado em uma variável local.</p></li>
<li><p>Por fim, devemos testar se o resultado do método é aquele esperado. Para isso, deve-se usar um comando chamado <strong>assert</strong>. Na verdade, o JUnit oferece diversas variações de <code>assert</code>, mas todas têm o mesmo objetivo: testar se um determinado resultado é igual a um valor esperado. No exemplo, usamos <code>assertTrue</code>, que verifica se o valor passado como parâmetro é verdadeiro.</p></li>
</ul>
<p>IDEs oferecem opções para rodar apenas os testes de um sistema, por exemplo, por meio de uma opção de menu chamada <q>Run as Test</q>. Ou seja, se o desenvolvedor chamar <q>Run</q>, ele irá executar o seu programa normalmente, começando pelo método <code>main</code>. No entanto, se ele optar pela opção <q>Run as Test</q> ele não irá executar o programa, mas apenas os seus testes de unidade.</p>
<p>A próxima figura mostra o resultado da execução do nosso primeiro teste. O resultado é mostrado na própria IDE e a barra verde informa que todos os testes passaram. Pode-se observar que o teste roda rapidamente, em 0.025 segundos.</p>
<p><img src="figs/cap8/run1.png" style="width:80.0%" /></p>
<p>Porém, suponha que tivéssemos cometido um erro na implementação da classe <code>Stack</code>. Por exemplo, suponha que o atributo <code>size</code> fosse inicializado com o valor 1, em vez de zero. Nesse caso, a execução dos testes iria falhar, como mostrado pela barra vermelha na IDE:</p>
<p><img src="figs/cap8/run2.png" style="width:80.0%" /></p>
<p>A mensagem de erro informa que houve uma falha durante a execução de <code>testEmptyStack</code>. Falha (<em>failure</em>) é o termo usado pelo JUnit para indicar testes cujo comando <code>assert</code> não foi satisfeito.</p>
<p>Em uma outra janela da IDE, pode-se descobrir que a asserção responsável pela falha encontra-se na linha 19 do arquivo <code>StackTest.java</code>.</p>
<p><img src="figs/cap8/run3.png" style="width:80.0%" /></p>
<p>Para concluir, vamos mostrar o código completo do teste de unidade:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">import</span><span class="im"> org.junit.Test;</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">import</span><span class="im"> org.junit.Before;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.assertTrue;</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.assertFalse;</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.assertEquals;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="kw">public</span> <span class="kw">class</span> StackTest {</span>
<span id="cb3-8"><a href="#cb3-8"></a></span>
<span id="cb3-9"><a href="#cb3-9"></a>  <span class="bu">Stack</span>&lt;<span class="bu">Integer</span>&gt; stack;</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>  <span class="at">@Before</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>() {</span>
<span id="cb3-13"><a href="#cb3-13"></a>    stack = <span class="kw">new</span> <span class="bu">Stack</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb3-14"><a href="#cb3-14"></a>  }</span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>  <span class="at">@Test</span></span>
<span id="cb3-17"><a href="#cb3-17"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStack</span>() {</span>
<span id="cb3-18"><a href="#cb3-18"></a>    <span class="fu">assertTrue</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb3-19"><a href="#cb3-19"></a>  }</span>
<span id="cb3-20"><a href="#cb3-20"></a></span>
<span id="cb3-21"><a href="#cb3-21"></a>  <span class="at">@Test</span></span>
<span id="cb3-22"><a href="#cb3-22"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testNotEmptyStack</span>() {</span>
<span id="cb3-23"><a href="#cb3-23"></a>    stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb3-24"><a href="#cb3-24"></a>    <span class="fu">assertFalse</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb3-25"><a href="#cb3-25"></a>  }</span>
<span id="cb3-26"><a href="#cb3-26"></a></span>
<span id="cb3-27"><a href="#cb3-27"></a>  <span class="at">@Test</span></span>
<span id="cb3-28"><a href="#cb3-28"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testSizeStack</span>() {</span>
<span id="cb3-29"><a href="#cb3-29"></a>    stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb3-30"><a href="#cb3-30"></a>    stack.<span class="fu">push</span>(<span class="dv">20</span>);</span>
<span id="cb3-31"><a href="#cb3-31"></a>    stack.<span class="fu">push</span>(<span class="dv">30</span>);</span>
<span id="cb3-32"><a href="#cb3-32"></a>    <span class="dt">int</span> size = stack.<span class="fu">size</span>();</span>
<span id="cb3-33"><a href="#cb3-33"></a>    <span class="fu">assertEquals</span>(<span class="dv">3</span>,size);</span>
<span id="cb3-34"><a href="#cb3-34"></a>  }</span>
<span id="cb3-35"><a href="#cb3-35"></a></span>
<span id="cb3-36"><a href="#cb3-36"></a>  <span class="at">@Test</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testPushPopStack</span>() {</span>
<span id="cb3-38"><a href="#cb3-38"></a>    stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb3-39"><a href="#cb3-39"></a>    stack.<span class="fu">push</span>(<span class="dv">20</span>);</span>
<span id="cb3-40"><a href="#cb3-40"></a>    stack.<span class="fu">push</span>(<span class="dv">30</span>);</span>
<span id="cb3-41"><a href="#cb3-41"></a>    <span class="dt">int</span> result = stack.<span class="fu">pop</span>();</span>
<span id="cb3-42"><a href="#cb3-42"></a>    result = stack.<span class="fu">pop</span>();</span>
<span id="cb3-43"><a href="#cb3-43"></a>    <span class="fu">assertEquals</span>(<span class="dv">20</span>,result);</span>
<span id="cb3-44"><a href="#cb3-44"></a>  }</span>
<span id="cb3-45"><a href="#cb3-45"></a></span>
<span id="cb3-46"><a href="#cb3-46"></a>  <span class="at">@Test</span>(expected = java.<span class="fu">util</span>.<span class="fu">EmptyStackException</span>.<span class="fu">class</span>)</span>
<span id="cb3-47"><a href="#cb3-47"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStackException</span>() {</span>
<span id="cb3-48"><a href="#cb3-48"></a>    stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb3-49"><a href="#cb3-49"></a>    <span class="dt">int</span> result = stack.<span class="fu">pop</span>();</span>
<span id="cb3-50"><a href="#cb3-50"></a>    result = stack.<span class="fu">pop</span>();</span>
<span id="cb3-51"><a href="#cb3-51"></a>  }</span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a>}</span></code></pre></div>
<p>A classe <code>StackTest</code> tem cinco métodos de teste — todos com anotações <code>@Test</code>. Existe ainda um método, chamado <code>init()</code>, com uma anotação <code>@Before</code>. Esse método é executado pelo JUnit antes de qualquer método de teste. O JUnit funciona do seguinte modo: para cada classe de teste, ele chama cada um de seus métodos <code>@Test</code>. Cada método executa em uma instância diferente da classe de teste. Ou seja, antes de chamar um método <code>@Test</code>, o JUnit instancia um objeto da sua classe. Se essa classe tiver um método <code>@Before</code>, ele é executado antes do método <code>@Test</code>. No exemplo, usamos um método <code>@Before</code> para criar uma instância de <code>Stack</code>, a qual é usada depois pelos métodos <code>@Test</code>. Assim, evitamos repetir esse código de instanciação nos testes.</p>
<p>Para ficar um pouco mais claro, mostramos a seguir o algoritmo usado pelo JUnit para executar os testes de um programa:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1"></a>para cada classe de teste TC</span>
<span id="cb4-2"><a href="#cb4-2"></a>  para cada método m de TC com anotação <span class="at">@Test</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    o = <span class="kw">new</span> <span class="fu">TC</span>();    <span class="co">// instancia objeto de teste</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    se C possui um método b com anotação <span class="at">@Before</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>         então o.<span class="fu">b</span>();   <span class="co">// chama método @Before, se existir</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    o.<span class="fu">m</span>();           <span class="co">// chamada método @Test</span></span></code></pre></div>
<p>Voltando à classe <code>StackTest</code>, outro método interessante é aquele que testa a situação na qual a execução de um <code>pop()</code> levanta uma <code>EmptyStackException</code>. Veja que esse método — o último do nosso teste — não possui <code>assert</code>. O motivo é que um <code>assert</code> seria um código morto na sua implementação. A chamada de um <code>pop()</code> em uma pilha vazia terminaria a execução do método com uma exceção <code>EmptyStackException</code>. Ou seja, o <code>assert</code> não seria executado. Por isso, a anotação <code>@Test</code> tem um atributo especial que serve para especificar a exceção que deve ser levantada pelo método de teste. Em resumo, <code>testEmptyException</code> vai passar se a sua execução levantar uma <code>EmptyStackException</code>. Caso contrário, ele vai falhar.</p>
<p><strong>Código Fonte</strong>: O código fonte de <code>Stack</code> e <code>StackTest</code> está disponível neste <a href="https://gist.github.com/mtov/3601acd0b32a1d0a85b4a81a43af4284">link</a>.</p>
<p><strong>Aviso:</strong> JUnit possui várias versões. No capítulo, vamos usar a versão 4.12.</p>
<h3 data-number="1.2.1" id="definições" data-number="1.2.1"><span class="header-section-number">8.2.1</span> Definições</h3>
<p>Antes de avançar, vamos apresentar algumas definições:</p>
<ul>
<li><p><strong>Teste</strong>: método que implementa um teste. O nome deriva da anotação <code>@Test</code>. São também chamados de método de teste (<em>test method</em>).</p></li>
<li><p><strong>Fixture</strong>: estado do sistema que será testado por um ou mais métodos de teste, incluindo dados, objetos, etc. O termo é reusado da indústria manufatureira, onde <em>fixture</em> é um equipamento que <q>fixa</q> uma peça que se pretende construir (veja uma <a href="https://en.wikipedia.org/wiki/Fixture_(tool)">foto</a> na Wikipedia). No contexto de testes de unidade, a função de uma fixture é <q>fixar</q> o estado — isto é, os dados e objetos — exercitados no teste.</p></li>
<li><p><strong>Casos de Teste (Test Case)</strong>: classe com os métodos de teste. O nome tem origem nas primeiras versões do JUnit. Nessas versões, os métodos de testes eram implementados em classes que herdavam de uma classe <code>TestCase</code>.</p></li>
<li><p><strong>Suíte de Testes (Test Suite)</strong>: conjunto de casos de teste, os quais são executados pelo framework de testes de unidade (no nosso caso, JUnit).</p></li>
<li><p><strong>Sistema sob Teste (System Under Test, SUT)</strong>: sistema que está sendo testado. É um nome genérico, usado também em outros tipos de testes, não necessariamente de unidades. Às vezes, usa-se também o termo <strong>código de produção</strong>, ou seja, código que vai ser executado pelos clientes do sistema.</p></li>
</ul>
<h3 data-number="1.2.2" id="quando-escrever-testes-de-unidade" data-number="1.2.2"><span class="header-section-number">8.2.2</span> Quando Escrever Testes de Unidade?</h3>
<p>Existem duas respostas principais para essa pergunta. Primeiro, pode-se escrever os testes após implementar uma pequena funcionalidade. Por exemplo, pode-se implementar alguns métodos e, em seguida, seus testes, que devem passar. Isto é, pode-se programar um pouco e escrever testes; programar mais um pouco e escrever novos testes, etc.</p>
<p>Alternativamente, pode-se escrever os testes primeiro, antes de qualquer código de produção. No início, esses testes não vão passar, somente depois que o código sob teste for implementado. Em outras palavras, inicia-se com um código que apenas compila e cujos testes, portanto, falham. Implementa-se então o código de produção e testa-se novamente. Agora, os testes devem passar. Esse estilo de desenvolvimento chama-se <strong>Test-Driven Development</strong>. Iremos discuti-lo com detalhes na Seção 8.7.</p>
<p>No entanto, existem duas respostas complementares para a questão sobre quando devemos escrever testes. Por exemplo, quando um usuário reportar um bug, pode-se começar sua análise escrevendo um teste que reproduz o bug e que, portanto, vai falhar. No passo seguinte, deve-se corrigir o bug. Se a correção for bem sucedida, o teste vai passar e ganhamos mais um teste para a suíte de testes.</p>
<p>Pode-se escrever testes também quando se estiver depurando um trecho de código. Por exemplo, evite escrever um <code>System.out.println</code> para testar manualmente o resultado de um método. Em vez disso, escreva um método de teste. Quando usa-se um <code>println</code>, ele em algum momento é removido. Já um teste tem a vantagem de contribuir com mais um teste para a suíte de testes.</p>
<p>Ainda sobre a pergunta principal desta seção, o que não é recomendável é deixar para implementar todos os testes após o sistema ficar pronto — tal como ocorria, por exemplo, com desenvolvimento em Waterfall. Se deixarmos para escrever os testes por último, eles podem ser construídos de forma apressada e com baixa qualidade. Ou então pode ser que eles nem sejam implementados, pois o sistema já estará funcionando e novas prioridades podem ter sido alocadas para o time de desenvolvimento. Por fim, não é recomendável que os testes sejam implementados por um outro time ou mesmo por uma outra empresa de desenvolvimento. Em vez disso, recomenda-se que o desenvolvedor de uma classe seja também responsável pela implementação de seus testes de unidade.</p>
<h3 data-number="1.2.3" id="benefícios" data-number="1.2.3"><span class="header-section-number">8.2.3</span> Benefícios</h3>
<p>O principal benefício de testes de unidade é encontrar bugs, ainda na fase de desenvolvimento e antes que o código entre em produção, quando os custos de correção e os prejuízos podem ser maiores. Portanto, se um sistema tem bons testes, é mais difícil que os usuários finais sejam surpreendidos com bugs.</p>
<p>Porém, existem dois outros benefícios que também são muito importantes. Primeiro, testes de unidade funcionam como uma rede de proteção contra <strong>regressões</strong> no código. Dizemos que uma regressão ocorre quando uma modificação realizada no código de um sistema — seja para corrigir um bug, implementar uma nova funcionalidade ou realizar uma refatoração — acaba por introduzir um bug ou outro problema semelhante no código. Ou seja, dizemos que o código regrediu porque algo que estava funcionando deixou de funcionar após a mudança que foi realizada. Regressões são mais raras quando se tem bons testes. Para isso, após concluir uma mudança o desenvolvedor deve rodar a suíte de testes. Se a mudança tiver introduzido alguma regressão, existe uma boa chance de que ela seja detectada pelos testes. Ou seja, antes da mudança os testes estavam passando, mas após a mudança algum teste começou a falhar.</p>
<p>Além de serem usados para detecção prematura de bugs e regressões no código, testes de unidade também ajudam na documentação e especificação do código de produção. De fato, ao olhar e analisar os testes implementados em <code>StackTest</code> podemos entender diversos aspectos do comportamento da classe <code>Stack</code>. Por isso, muitas vezes, antes de manter um código com o qual ele não tenha familiaridade, um desenvolvedor começa analisando os seus testes.</p>
<p><strong>Mundo Real</strong>: Dentre as práticas de desenvolvimento propostas originalmente por métodos ágeis, testes de unidade é provavelmente a que alcançou o maior impacto e que é mais largamente usada. Hoje, os mais diversos sistemas de software, de empresas dos mais diferentes tamanhos, são desenvolvidos com o apoio de testes de unidade. A seguir, vamos destacar os casos de duas grandes empresas de software: Google e Facebook. Os comentários foram extraídos de artigos que documentam o processo e as práticas de desenvolvimento de software dessas empresas:</p>
<ul>
<li><p><q>Testes de unidade são fortemente encorajados e amplamente praticados no Google. Todo código de produção deve ter testes de unidade e nossa ferramenta de revisão de código automaticamente destaca código submetido sem os correspondentes testes. Os revisores de código normalmente exigem que qualquer mudança que adiciona novas funcionalidades deve também adicionar os respectivos testes.</q> (<a href="https://arxiv.org/abs/1702.01715">link</a>)</p></li>
<li><p><q>No Facebook, engenheiros são responsáveis pelos teste de unidade de qualquer código novo que eles desenvolvam. Além disso, esse código deve passar por testes de regressão, os quais são executados automaticamente, como parte dos processos de commit e push.</q> (<a href="https://research.fb.com/publications/development-and-deployment-at-facebook/">link</a>)</p></li>
</ul>
<h2 data-number="1.3" id="princípios-e-smells" data-number="1.3"><span class="header-section-number">8.3</span> Princípios e Smells</h2>
<p>Nesta seção, vamos agrupar a apresentação de princípios e anti-padrões para implementação de testes de unidade. O objetivo é discutir questões importantes para a implementação de testes que tenham qualidade e que possam ser facilmente mantidos e entendidos.</p>
<h3 data-number="1.3.1" id="princípios-first" data-number="1.3.1"><span class="header-section-number">8.3.1</span> Princípios FIRST</h3>
<p>Testes de unidades devem satisfazer às seguintes propriedades (cujas iniciais dão origem à palavra FIRST, em Inglês):</p>
<p><strong>Rápidos (Fast)</strong>: desenvolvedores devem executar testes de unidades frequentemente, para obter feedback rápido sobre bugs e regressões no código. Por isso, é importante que eles sejam executados rapidamente, em questões de milisegundos. Se isso não for possível, pode-se dividir uma suíte de testes em dois grupos: testes que executam rapidamente e que, portanto, serão frequentemente chamados; e testes mais demorados, que serão, por exemplo, executados uma vez por dia.</p>
<p><strong>Independentes</strong>: a ordem de execução dos testes de unidade não é importante. Para quaisquer testes T1 e T2, a execução de T1 seguida de T2 deve ter o mesmo resultado da execução de T2 e depois T1. Pode acontecer ainda de T1 e T2 serem executados de forma concorrente. Para que os testes sejam independentes, T1 não deve alterar alguma parte do estado global do sistema que depois será usada para computar o resultado de T2 e vice-versa.</p>
<p><strong>Determinísticos (Repeatable)</strong>: testes de unidade devem ter sempre o mesmo resultado. Ou seja, se um teste T é chamado <em>n</em> vezes, o resultado deve ser o mesmo nas <em>n</em> execuções. Isto é, ou T passa em todas as execuções; ou ele sempre falha. Testes com resultados não-determinísticos são chamados de <strong>Testes Flaky</strong> (ou <strong>Testes Erráticos</strong>). Concorrência é uma das principais responsáveis por comportamento flaky. Um exemplo é mostrado a seguir:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1"></a><span class="at">@Test</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">public</span> <span class="dt">void</span> exemploTesteFlaky {</span>
<span id="cb5-3"><a href="#cb5-3"></a>  TaskResult resultado;</span>
<span id="cb5-4"><a href="#cb5-4"></a>  MyMath m = <span class="kw">new</span> <span class="fu">MyMath</span>();</span>
<span id="cb5-5"><a href="#cb5-5"></a>  m.<span class="fu">asyncPI</span>(<span class="dv">10</span>,resultado);</span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="bu">Thread</span>.<span class="fu">sleep</span>(<span class="dv">1000</span>);</span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="fu">assertEquals</span>(<span class="fl">3.</span><span class="dv">1415926535</span>, resultado.<span class="fu">get</span>());</span>
<span id="cb5-8"><a href="#cb5-8"></a>}</span></code></pre></div>
<p>Esse teste chama uma função que calcula o valor de PI, com uma certa precisão, e de forma assíncrona — isto é, a função realiza o seu cálculo em uma nova thread, que ela mesmo cria internamente. No exemplo, a precisão requerida são 10 casas decimais. O teste faz uso de um <code>sleep</code> para esperar que a função assíncrona termine. No entanto, isso torna o seu comportamento não-determinístico: se a função terminar antes de 1000 milissegundos, o teste irá passar; mas se a execução, por alguma circunstância particular, demorar mais, o teste irá falhar. Uma possível alternativa seria testar apenas a versão síncrona da função. Se essa versão não existir, um refactoring poderia ser realizado para extraí-la do código da versão assíncrona. Na Seção 8.5, iremos discutir mais sobre questões relativas à testabilidade do código de produção.</p>
<p>Pode parecer que testes flaky são raros, mas um estudo divulgado pelo Google, com seus próprios testes, revelou que cerca de 16% deles estão sujeitos a resultados não-determinísticos (<a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html">link</a>). Ou seja, esses testes podem falhar não porque um bug foi introduzido no código, mas por causa de eventos não determinísticos, como uma thread que levou mais tempo para executar. Testes flaky são ruins porque eles atrasam o desenvolvimento: os programadores perdem um tempo para investigar a falha, para então descobrir que ela é um alarme falso.</p>
<p><strong>Auto-verificáveis (Self-checking)</strong>: O resultado de um teste de unidades deve ser facilmente verificável. Para interpretar o resultado do teste, o desenvolvedor não deve, por exemplo, ter que abrir e analisar um arquivo de saída ou fornecer dados manualmente. Em vez disso, o resultado dos testes deve ser binário e mostrado na IDE, normalmente por meio de componentes que ficam com a cor verde (para indicar que todos os testes passaram) ou com a cor vermelha (para indicar que algum teste falhou). Adicionalmente, quando um teste falha, deve ser possível identificar essa falha de forma rápida, incluindo a localização do comando <code>assert</code> que falhou.</p>
<p><strong>Escritos o quanto antes (Timely)</strong>, se possível antes mesmo do código que vai ser testado, como já comentamos no final da Seção 8.2 e iremos discutir com mais profundidade na seção sobre Desenvolvimento Dirigido por Testes (Seção 8.6).</p>
<h3 data-number="1.3.2" id="test-smells" data-number="1.3.2"><span class="header-section-number">8.3.2</span> Test Smells</h3>
<p><strong>Test Smells</strong> representam estruturas e características <q>preocupantes</q> no código de testes de unidade, as quais, a princípio deveriam ser evitadas. O nome é uma adaptação, para o contexto de testes, do conceito de <strong>Code Smells</strong> ou <strong>Bad Smells</strong>, que iremos estudar no Capítulo 9. No entanto, neste capítulo, vamos aproveitar e já comentar sobre smells que podem ocorrer no código de testes.</p>
<p>Um <strong>Teste Obscuro</strong> é um teste longo, complexo e difícil de entender. Como afirmamos, testes devem ser usados também para auxiliar na documentação do sistema sob teste. Por isso, é importante que eles tenham uma lógica clara e de rápido entendimento. Idealmente, um teste deve, por exemplo, testar um único requisito do sistema sob teste.</p>
<p>Um <strong>Teste com Lógica Condicional</strong> inclui código que pode ou não ser executado. Isto é, são testes com comandos <code>if</code>, laços, etc, quando o ideal é que os testes de unidade sejam lineares. Lógica condicional em testes é considerada um smell porque ela prejudica o entendimento do teste.</p>
<p><strong>Duplicação de Código em Testes</strong> ocorre, como o próprio nome sugere, quando temos código repetido em diversos métodos de teste.</p>
<p>No entanto, um test smell não deve ser interpretado ao pé da letra, isto é, como sendo uma situação que deve ser evitada a todo custo. Em vez disso, eles devem ser considerados como um alerta para os implementadores do teste. Ao identificar um test smell, os desenvolvedores devem refletir sobre se não é possível ter um teste mais simples e menor, com um código linear e sem duplicação de comandos.</p>
<p>Por fim, assim como ocorre com código de produção, código de testes deve ser frequentemente refatorado, de modo a garantir que ele permaneça simples, fácil de entender e livre dos test smells que comentamos nesta seção.</p>
<h3 data-number="1.3.3" id="número-de-assert-por-teste" data-number="1.3.3"><span class="header-section-number">8.3.3</span> Número de assert por Teste</h3>
<p>Alguns autores (<a href="https://dl.acm.org/citation.cfm?id=1388398">link</a>) recomendam que deve existir no máximo um <code>assert</code> por teste. Ou seja, eles recomendam escrever um código como o seguinte.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1"></a><span class="at">@Test</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStack</span>() {</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="fu">assertTrue</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb6-4"><a href="#cb6-4"></a>}</span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="at">@Test</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testNotEmptyStack</span>() {</span>
<span id="cb6-8"><a href="#cb6-8"></a>  stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb6-9"><a href="#cb6-9"></a>  <span class="fu">assertFalse</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb6-10"><a href="#cb6-10"></a>}</span></code></pre></div>
<p>Em outras palavras, <em>não</em> recomenda-se dois comandos <code>assert</code> no mesmo método, como no código a seguir: </p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1"></a><span class="at">@Test</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStack</span>() {</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="fu">assertTrue</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb7-4"><a href="#cb7-4"></a>  stack.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="fu">assertFalse</span>(stack.<span class="fu">isEmpty</span>());</span>
<span id="cb7-6"><a href="#cb7-6"></a>}</span></code></pre></div>
<p>O primeiro exemplo, que divide o teste de pilha vazia em dois testes, tende a ser mais legível e fácil de entender do que o segundo, que faz tudo em um único teste. Além disso, quando o teste do primeiro exemplo falha, é mais simples detectar o motivo da falha do que no segundo exemplo, que pode falhar por dois motivos.</p>
<p>No entanto, não devemos ser dogmáticos no emprego dessa regra (<a href="https://dl.acm.org/citation.cfm?id=1076526">link</a>, Capítulo 4). O motivo é que existem casos onde justifica-se ter mais de um <code>assert</code> por método. Por exemplo, suponha que precisamos testar uma função <code>getBook</code> que retorna um objeto com dados de um livro, incluindo título, autor, ano e editora. Nesse caso, justifica-se ter quatro comandos <code>assert</code> no mesmo teste, cada um verificando um dos campos do objeto retornado pela função, como mostra o seguinte código.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1"></a><span class="at">@Test</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testBookService</span>() {</span>
<span id="cb8-3"><a href="#cb8-3"></a>  BookService bs = <span class="kw">new</span> <span class="fu">BookService</span>();</span>
<span id="cb8-4"><a href="#cb8-4"></a>  <span class="bu">Book</span> b = bs.<span class="fu">getBook</span>(<span class="dv">1234</span>);</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;Engenharia Software Moderna&quot;</span>, b.<span class="fu">getTitle</span>());</span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;Marco Tulio Valente&quot;</span>, b.<span class="fu">getAuthor</span>());</span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;2020&quot;</span>, g.<span class="fu">getYear</span>());</span>
<span id="cb8-8"><a href="#cb8-8"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;ASERG/DCC/UFMG&quot;</span>, g.<span class="fu">getPublisher</span>());</span>
<span id="cb8-9"><a href="#cb8-9"></a>}</span></code></pre></div>
<p>Uma segunda exceção é quando temos um método simples, que pode ser testado por meio de um único <code>assert</code>. Para ilustrar, mostramos o teste da função <code>repeat</code> da classe <code>Strings</code> da biblioteca <code>google/guava</code> (<a href="https://github.com/google/guava/blob/master/guava-tests/test/com/google/common/base/StringsTest.java">link</a>):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1"></a><span class="at">@Test</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testRepeat</span>() {</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="bu">String</span> input = <span class="st">&quot;20&quot;</span>;</span>
<span id="cb9-4"><a href="#cb9-4"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;&quot;</span>, Strings.<span class="fu">repeat</span>(input,<span class="dv">0</span>));</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;20&quot;</span>, Strings.<span class="fu">repeat</span>(input,<span class="dv">1</span>));</span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;2020&quot;</span>, Strings.<span class="fu">repeat</span>(input,<span class="dv">2</span>));</span>
<span id="cb9-7"><a href="#cb9-7"></a>  <span class="fu">assertEquals</span>(<span class="st">&quot;202020&quot;</span>, Strings.<span class="fu">repeat</span>(input,<span class="dv">3</span>));</span>
<span id="cb9-8"><a href="#cb9-8"></a>  ...</span>
<span id="cb9-9"><a href="#cb9-9"></a>}</span></code></pre></div>
<p>Nesse teste, temos quatro comandos <code>assertEquals</code>, os quais testam, respectivamente, o resultado da repetição de uma determinada string zero, uma, duas e três vezes.</p>
<h2 data-number="1.4" id="cobertura-de-testes" data-number="1.4"><span class="header-section-number">8.4</span> Cobertura de Testes</h2>
<p>Cobertura de testes é uma métrica que ajuda a definir o número de testes que precisamos escrever para um programa. Ela mede o percentual de comandos de um programa que são cobertos por testes, isto é:</p>
<blockquote>
<p>cobertura de testes = (número de comandos executados pelos testes) / (total de comandos do programa)</p>
</blockquote>
<p>Existem ferramentas para cálculo de cobertura de testes. Na próxima figura, mostramos um exemplo de uso da ferramenta que acompanha a IDE Eclipse. As linhas com fundo verde — coloridas automaticamente por essa ferramenta — indicam as linhas cobertas pelos cinco testes implementados em <code>StackTest</code>. As únicas linhas não coloridas de verde são responsáveis pela assinatura dos métodos de <code>Stack</code> e, portanto, não correspondem a comandos executáveis. Assim, a cobertura dos testes do nosso primeiro exemplo é de 100%, pois a execução dos métodos de testes implica na execução de todos os comandos da classe <code>Stack</code>.</p>
<p><img src="figs/cap8/cobertura1.png" style="width:70.0%" /></p>
<p>Suponha agora que não tivéssemos implementado o teste <code>testEmptyStackException</code>. Isto é, não iríamos testar o levantamento de uma exceção pelo método <code>pop()</code>, quando chamado com uma pilha vazia. Nesse caso, a cobertura dos testes cairia para 92.9%, como ilustrado a seguir:</p>
<p><img src="figs/cap8/cobertura3.png" style="width:100.0%" /></p>
<p>Nesse caso, a ferramenta de cálculo de cobertura de testes marcaria as linhas da classe <code>Stack</code> da seguinte forma:</p>
<p><img src="figs/cap8/cobertura2.png" style="width:70.0%" /></p>
<p>Como afirmamos, as linhas verdes são cobertas pela execução dos testes. Porém, existe um comando marcado de amarelo. Essa cor indica que o comando é um desvio (no caso, um <code>if</code>) e que apenas um dos caminhos possíveis do desvio (no caso, o caminho <code>false</code>) foi exercitado pelos testes de unidade. Por fim, o leitor já deve ter observado que existe uma linha em vermelho. Essa cor indica linhas que não foram cobertas pelos testes de unidade.</p>
<p>Em Java, ferramentas de cobertura de testes trabalham instrumentando os bytecodes gerados pelo compilador da linguagem. Como mostrado na figura com as estatísticas de cobertura, o programa anterior, após compilado, possui 52 instruções cobertas por testes de unidade, de um total de 56 instruções. Portanto, sua cobertura é 52 / 56 = 92.9%.</p>
<h3 data-number="1.4.1" id="qual-a-cobertura-de-testes-ideal" data-number="1.4.1"><span class="header-section-number">8.4.1</span> Qual a Cobertura de Testes Ideal?</h3>
<p>Não existe um número mágico e absoluto para cobertura de testes. A resposta varia de projeto para projeto, dependendo da complexidade dos requisitos, da criticidade do projeto, etc. Mas, em geral, não precisa ser 100%, pois sempre existem métodos triviais em um sistema; por exemplo, <em>getters</em> e <em>setters</em>. Também sempre temos métodos cujo teste é mais desafiador, como métodos de interface com o usuário ou métodos com comportamento assíncrono.</p>
<p>Portanto, não recomenda-se fixar um valor de cobertura que tenha que ser sempre atingido. Em vez disso, deve-se monitorar a evolução dos valores de cobertura ao longo do tempo, para verificar se os desenvolvedores, por exemplo, não estão relaxando na escrita de testes. Recomenda-se também avaliar cuidadosamente os trechos não cobertos por testes, para confirmar que eles não são relevantes ou então são difíceis de serem testados.</p>
<p>Feitas essas considerações, times que valorizam a escrita de testes costumam atingir facilmente valores de cobertura próximos de 70% (<a href="https://dl.acm.org/citation.cfm?id=2808995">link</a>). Por outro lado, valores abaixo de 50% tendem a ser preocupantes (<a href="https://martinfowler.com/bliki/TestCoverage.html">link</a>). Por fim, mesmo quando se usa TDD, a cobertura de testes costuma não chegar a 100%, embora normalmente fique acima de 90% (<a href="https://dl.acm.org/citation.cfm?id=2808995">link</a>).</p>
<p><strong>Mundo Real</strong>: Em uma conferência de desenvolvedores do Google, em 2014, foram apresentadas algumas estatísticas sobre a cobertura de testes dos sistemas da empresa (veja os <a href="https://docs.google.com/presentation/d/1god5fDDd1aP6PwhPodOnAZSPpD80lqYDrHhuhyD7Tvg/edit?usp=sharing">slides</a> e também o <a href="https://youtu.be/4bublRBCLVQ">vídeo</a>). Na mediana, os sistemas do Google tinham 78% de cobertura, em nível de comandos. Segundo afirmou-se na palestra, a recomendação seria atingir 85% de cobertura na maioria dos sistemas, embora essa recomendação não seria <q>escrita em pedra</q>, ou seja, não teria que ser seguida de forma dogmática. Mostrou-se também que a cobertura variava por linguagem de programação. A menor cobertura era dos sistemas em C++, um pouco inferior a 60% na média dos projetos. A maior foi medida para sistemas implementados em Python, um pouco acima de 80%.</p>
<h3 data-number="1.4.2" id="outras-definições-de-cobertura-de-testes" data-number="1.4.2"><span class="header-section-number">8.4.2</span> Outras Definições de Cobertura de Testes</h3>
<p>A definição de métrica de cobertura, apresentada acima, foi baseada em comandos, pois trata-se de sua definição mais comum. Porém, existem definições alternativas, tais como <strong>cobertura de funções</strong> (percentual de funções que são executadas por um teste), <strong>cobertura de chamadas de funções</strong> (dentre todas as linhas de um programa que chamam funções, quantas são de fato, exercitadas por testes), <strong>cobertura de branches</strong> (% de branches de um programa que são executados por testes; um comando <code>if</code> sempre gera dois branches: quando a condição é verdadeira e quando ela é falsa). Cobertura de comandos e de branches são também chamadas de <strong>Cobertura C0</strong> e <strong>Cobertura C1</strong>, respectivamente. Para ilustrar a diferença entre ambas vamos usar a seguinte classe (primeiro código) e seu teste de unidade (segundo código):</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">public</span> <span class="kw">class</span> <span class="bu">Math</span> {</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">public</span> <span class="dt">int</span> <span class="fu">abs</span>(<span class="dt">int</span> x) {</span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">if</span> (x &lt; <span class="dv">0</span>) {  </span>
<span id="cb10-5"><a href="#cb10-5"></a>      x = -x;</span>
<span id="cb10-6"><a href="#cb10-6"></a>    }  </span>
<span id="cb10-7"><a href="#cb10-7"></a>    <span class="kw">return</span> x;</span>
<span id="cb10-8"><a href="#cb10-8"></a>  }</span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">public</span> <span class="kw">class</span> MathTest {</span>
<span id="cb11-2"><a href="#cb11-2"></a></span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="at">@Test</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testAbs</span>() {</span>
<span id="cb11-5"><a href="#cb11-5"></a>    <span class="bu">Math</span> m = <span class="kw">new</span> <span class="bu">Math</span>();</span>
<span id="cb11-6"><a href="#cb11-6"></a>    <span class="fu">assertEquals</span>(<span class="dv">1</span>,m.<span class="fu">abs</span>(-<span class="dv">1</span>));</span>
<span id="cb11-7"><a href="#cb11-7"></a>  }</span>
<span id="cb11-8"><a href="#cb11-8"></a></span>
<span id="cb11-9"><a href="#cb11-9"></a>}</span></code></pre></div>
<p>Supondo cobertura de comandos, temos uma cobertura de 100%. Porém, supondo uma cobertura de branches, o valor é 50%, pois dentre as duas condições possíveis do comando <code>if(x &lt; 0)</code>, testamos apenas uma delas (a condição verdadeira). Se quisermos ter uma cobertura de branches de 100% teríamos que adicionar mais um comando <code>assert</code>, como: <code>assertEquals(1,m.abs(1))</code>. Logo, cobertura de branches é mais rigorosa do que cobertura de comandos.</p>
<h2 data-number="1.5" id="testabilidade" data-number="1.5"><span class="header-section-number">8.5</span> Testabilidade</h2>
<p>Testabilidade é uma medida de quão fácil é implementar testes para um sistema. Como vimos, é importante que os testes sigam os princípios FIRST, que eles tenham poucos <code>assert</code> e uma alta cobertura. No entanto, é importante também que o projeto do código de produção favoreça a implementação de testes. O termo em inglês para isso é <strong>design for testability</strong>. Em outras palavras, às vezes, parte relevante do esforço para escrita de bons testes deve ser alocada no projeto do sistema sob teste e não exatamente no projeto dos testes.</p>
<p>A boa notícia é que código que segue as propriedades e princípios de projeto que discutimos no Capítulo 5 — tais como coesão alta, acoplamento baixo, responsabilidade única, separação entre apresentação e modelo, inversão de dependências, Demeter, dentre outros — tende a apresentar boa testabilidade.</p>
<h3 data-number="1.5.1" id="exemplo-servlet" data-number="1.5.1"><span class="header-section-number">8.5.1</span> Exemplo: Servlet</h3>
<p>Servlet é uma tecnologia de Java para implementação de páginas Web dinâmicas. A seguir mostramos uma servlet que calcula o índice de massa corporal de uma pessoa, dado o seu peso e altura. O nosso objetivo é didático. Logo, não vamos detalhar todo o protocolo para implementação de servlets. Além disso, a lógica de domínio desse exemplo é simples, consistindo na seguinte fórmula: <code>peso / (altura * altura)</code>. Mas tente imaginar que essa lógica poderia ser mais complexa e que, mesmo assim, a solução que vamos apresentar continuaria válida.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1"></a><span class="kw">public</span> <span class="kw">class</span> IMCServlet <span class="kw">extends</span> HttpServtet {</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">doGet</span>(HttpServletRequest req, </span>
<span id="cb12-4"><a href="#cb12-4"></a>                    HttpServletResponse res) {</span>
<span id="cb12-5"><a href="#cb12-5"></a>    res.<span class="fu">setContentType</span>(<span class="st">&quot;text/html&quot;</span>);</span>
<span id="cb12-6"><a href="#cb12-6"></a>    <span class="bu">PrintWriter</span> out = res.<span class="fu">getWriter</span>();</span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="bu">String</span> peso = req.<span class="fu">getParameter</span>(<span class="st">&quot;peso&quot;</span>);</span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="bu">String</span> altura = req.<span class="fu">getParameter</span>(<span class="st">&quot;altura&quot;</span>);</span>
<span id="cb12-9"><a href="#cb12-9"></a>      <span class="kw">try</span>{</span>
<span id="cb12-10"><a href="#cb12-10"></a>        <span class="dt">double</span> p = <span class="bu">Double</span>.<span class="fu">parseDouble</span>(peso);</span>
<span id="cb12-11"><a href="#cb12-11"></a>        <span class="dt">double</span> a = <span class="bu">Double</span>.<span class="fu">parseDouble</span>(altura);</span>
<span id="cb12-12"><a href="#cb12-12"></a>        <span class="dt">double</span> imc = p / (a * a);</span>
<span id="cb12-13"><a href="#cb12-13"></a>        out.<span class="fu">println</span>(<span class="st">&quot;Índice de Massa Corporal (IMC): &quot;</span> + imc);</span>
<span id="cb12-14"><a href="#cb12-14"></a>      }</span>
<span id="cb12-15"><a href="#cb12-15"></a>      <span class="kw">catch</span> (<span class="bu">NumberFormatException</span> e) {</span>
<span id="cb12-16"><a href="#cb12-16"></a>        out.<span class="fu">println</span>(<span class="st">&quot;Dados devem ser numéricos&quot;</span>);</span>
<span id="cb12-17"><a href="#cb12-17"></a>      }</span>
<span id="cb12-18"><a href="#cb12-18"></a>  }</span>
<span id="cb12-19"><a href="#cb12-19"></a>}  </span></code></pre></div>
<p>Primeiro, veja que não é simples escrever um teste para <code>IMCServlet</code>, pois essa classe depende de diversos tipos do pacote de Servlets de Java. Por exemplo, não é trivial instanciar um objeto do tipo <code>IMCServlet</code> e depois chamar <code>doGet</code>. Se tomarmos esse caminho, teríamos que criar também objetos dos tipos <code>HTTPServletRequest</code> e <code>HTTPServletResponse</code>, para passar como parâmetro de <code>doGet</code>. No entanto, esses dois tipos podem depender de outros tipos e assim sucessivamente. Portanto, a testabilidade de <code>IMCServlet</code> é baixa.</p>
<p>Uma alternativa para testar o exemplo mostrado seria extrair a sua lógica de domínio para uma classe separada, como feito no código a seguir. Ou seja, a ideia consiste em separar apresentação (via Servlet) de lógica de domínio. Com isso, fica mais fácil testar a classe extraída, chamada <code>IMCModel</code>, pois ela não depende de tipos relacionados com Servlet. Por exemplo, é mais fácil instanciar um objeto da classe <code>IMCModel</code> do que da classe <code>IMCServlet</code>. É verdade que com essa refatoração não vamos testar o código completo. Porém, é melhor testar a parte de domínio do sistema do que deixar o código inteiramente descoberto de testes.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">class</span> IMCModel{</span>
<span id="cb13-2"><a href="#cb13-2"></a>  <span class="kw">public</span> <span class="dt">double</span> <span class="fu">calculaIMC</span>(<span class="bu">String</span> p1, <span class="bu">String</span> a1) </span>
<span id="cb13-3"><a href="#cb13-3"></a>                <span class="kw">throws</span> <span class="bu">NumberFormatException</span> {</span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="dt">double</span> p = <span class="bu">Double</span>.<span class="fu">parseDouble</span>(p1);</span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="dt">double</span> a = <span class="bu">Double</span>.<span class="fu">parseDouble</span>(a1);</span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="kw">return</span> p / (a * a);</span>
<span id="cb13-7"><a href="#cb13-7"></a>  }</span>
<span id="cb13-8"><a href="#cb13-8"></a>}</span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="kw">public</span> <span class="kw">class</span> IMCServlet <span class="kw">extends</span> HttpServtet {</span>
<span id="cb13-11"><a href="#cb13-11"></a>  IMCModel model = <span class="kw">new</span> <span class="fu">IMCModel</span>();</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">doGet</span>(HttpServletRequest req, </span>
<span id="cb13-14"><a href="#cb13-14"></a>                    HttpServletResponse res) {</span>
<span id="cb13-15"><a href="#cb13-15"></a>    res.<span class="fu">setContentType</span>(<span class="st">&quot;text/html&quot;</span>);</span>
<span id="cb13-16"><a href="#cb13-16"></a>    <span class="bu">PrintWriter</span> out = res.<span class="fu">getWriter</span>();</span>
<span id="cb13-17"><a href="#cb13-17"></a>    <span class="bu">String</span> peso = req.<span class="fu">getParameter</span>(<span class="st">&quot;peso&quot;</span>);</span>
<span id="cb13-18"><a href="#cb13-18"></a>    <span class="bu">String</span> altura = req.<span class="fu">getParameter</span>(<span class="st">&quot;altura&quot;</span>);</span>
<span id="cb13-19"><a href="#cb13-19"></a>    <span class="kw">try</span> {</span>
<span id="cb13-20"><a href="#cb13-20"></a>      <span class="dt">double</span> imc = model.<span class="fu">calculaIMC</span>(peso, altura);</span>
<span id="cb13-21"><a href="#cb13-21"></a>      out.<span class="fu">println</span>(<span class="st">&quot;Índice de Massa Corporal (IMC): &quot;</span> + imc);</span>
<span id="cb13-22"><a href="#cb13-22"></a>    }</span>
<span id="cb13-23"><a href="#cb13-23"></a>    <span class="kw">catch</span> (<span class="bu">NumberFormatException</span> e) {</span>
<span id="cb13-24"><a href="#cb13-24"></a>      out.<span class="fu">println</span>(<span class="st">&quot;Dados devem ser numéricos&quot;</span>);</span>
<span id="cb13-25"><a href="#cb13-25"></a>    }</span>
<span id="cb13-26"><a href="#cb13-26"></a>  }</span>
<span id="cb13-27"><a href="#cb13-27"></a>}  </span></code></pre></div>
<p><strong>Código Fonte</strong>: O código dessa servlet está disponível neste <a href="https://gist.github.com/mtov/72a7da4aed79818fbd6aae4e0774d6a5">link</a>.</p>
<h3 data-number="1.5.2" id="exemplo-chamada-assíncrona" data-number="1.5.2"><span class="header-section-number">8.5.2</span> Exemplo: Chamada Assíncrona</h3>
<p>O próximo código mostra a implementação da função <code>asyncPI</code> que mencionamos na Seção 8.3 quando tratamos dos princípios FIRST e, especificamente, de testes determinísticos. Conforme explicamos nessa seção, não é simples testar uma função assíncrona, pois seu resultado é computado por uma thread independente. O exemplo que mostramos na Seção 8.3 usava um sleep para esperar o resultado ficar disponível. Porém, o uso desse comando torna o teste não-determinístico.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">public</span> <span class="kw">class</span> MyMath {</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">asyncPI</span>(<span class="dt">int</span> prec, TaskResult task) { </span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="kw">new</span> <span class="bu">Thread</span> (<span class="kw">new</span> <span class="bu">Runnable</span>() {</span>
<span id="cb14-5"><a href="#cb14-5"></a>      <span class="kw">public</span> <span class="dt">void</span> <span class="fu">run</span>() {</span>
<span id="cb14-6"><a href="#cb14-6"></a>        <span class="dt">double</span> pi = <span class="st">&quot;calcula PI com precisão prec&quot;</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>        task.<span class="fu">setResult</span>(pi);</span>
<span id="cb14-8"><a href="#cb14-8"></a>      }</span>
<span id="cb14-9"><a href="#cb14-9"></a>    }).<span class="fu">start</span>();</span>
<span id="cb14-10"><a href="#cb14-10"></a>  }</span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>} </span></code></pre></div>
<p>A seguir mostramos uma solução para incrementar a testabilidade dessa classe. Primeiro, extraímos o código que implementa a computação de PI para uma função separada, chamada <code>syncPI</code>. Assim, apenas essa função seria testada por um teste de unidade. Em suma, vale a observação que fizemos antes: é melhor extrair uma função que seja fácil de ser testada, do que deixar o código sem testes.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">public</span> <span class="kw">class</span> MyMath{</span>
<span id="cb15-2"><a href="#cb15-2"></a>  <span class="kw">public</span> <span class="dt">double</span> <span class="fu">syncPI</span>(<span class="dt">int</span> prec) {</span>
<span id="cb15-3"><a href="#cb15-3"></a>    <span class="dt">double</span> pi = <span class="st">&quot;calcula PI com precisão prec&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="kw">return</span> pi;</span>
<span id="cb15-5"><a href="#cb15-5"></a>  }</span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">asyncPI</span>(<span class="dt">int</span> prec, TaskResult task) { </span>
<span id="cb15-7"><a href="#cb15-7"></a>    <span class="kw">new</span> <span class="bu">Thread</span> (<span class="kw">new</span> <span class="bu">Runnable</span>() {</span>
<span id="cb15-8"><a href="#cb15-8"></a>      <span class="kw">public</span> <span class="dt">void</span> <span class="fu">run</span>() {</span>
<span id="cb15-9"><a href="#cb15-9"></a>        <span class="dt">double</span> pi = <span class="fu">syncPI</span>(prec);</span>
<span id="cb15-10"><a href="#cb15-10"></a>        task.<span class="fu">setResult</span>(pi);</span>
<span id="cb15-11"><a href="#cb15-11"></a>      }    </span>
<span id="cb15-12"><a href="#cb15-12"></a>    }).<span class="fu">start</span>();</span>
<span id="cb15-13"><a href="#cb15-13"></a>  }</span>
<span id="cb15-14"><a href="#cb15-14"></a>}  </span></code></pre></div>
<p><strong>Código Fonte</strong>: O código desse exemplo de chamada assíncrona está disponível neste <a href="https://gist.github.com/mtov/a3f73350010758925172a7f433e2ba71">link</a>.</p>
<h2 data-number="1.6" id="mocks" data-number="1.6"><span class="header-section-number">8.6</span> Mocks</h2>
<p>Para explicar o papel desempenhado por mocks em testes de unidade, vamos começar com um exemplo motivador e discutir porque é difícil escrever um teste de unidade para ele. Em seguida, vamos introduzir o conceito de mocks como uma possível solução para testar esse exemplo.</p>
<p><strong>Aviso:</strong> Neste capítulo, usamos <strong>mock</strong> como sinônimo de <strong>stub</strong>. No entanto, incluímos uma subseção mais à frente para ressaltar que alguns autores fazem uma distinção entre esses termos.</p>
<p><strong>Exemplo Motivador:</strong> Para explicar o conceito de mocks, vamos partir de uma classe simples para pesquisa de livros, cujo código é mostrado a seguir. Essa classe, chamada <code>BookSearch</code>, implementa um método <code>getBook</code>, que pesquisa os dados de um livro em um serviço remoto. Esse serviço, por sua vez, implementa a interface <code>BookService</code>. Para o exemplo ficar mais real, suponha que <code>BookService</code> é uma API REST ou uma base de dados. O importante é que a pesquisa é realizada em outro sistema, que fica abstraído pela interface <code>BookService</code>. Esse serviço retorna o seu resultado como um documento JSON, isto é, um documento textual. Assim, cabe ao método <code>getBook</code> acessar o serviço remoto, obter a resposta em formato JSON e criar um objeto da classe <code>Book</code> para armazenar a resposta. Para simplificar o exemplo, não mostramos o código da classe <code>Book</code>, mas ela é apenas uma classe com dados de livros e seus respectivos métodos <code>get</code>. Na verdade, para simplificar um pouco mais, o exemplo considera que <code>Book</code> possui um único campo, relativo ao seu título. Em um programa real, <code>Book</code> teria outros campos, que também seriam tratados em <code>getBook</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">import</span><span class="im"> org.json.JSONObject;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">public</span> <span class="kw">class</span> BookSearch {</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a>  BookService rbs;</span>
<span id="cb16-6"><a href="#cb16-6"></a></span>
<span id="cb16-7"><a href="#cb16-7"></a>  <span class="kw">public</span> <span class="fu">BookSearch</span>(BookService rbs) {</span>
<span id="cb16-8"><a href="#cb16-8"></a>    <span class="kw">this</span>.<span class="fu">rbs</span> = rbs;</span>
<span id="cb16-9"><a href="#cb16-9"></a>  }</span>
<span id="cb16-10"><a href="#cb16-10"></a></span>
<span id="cb16-11"><a href="#cb16-11"></a>  <span class="kw">public</span> <span class="bu">Book</span> <span class="fu">getBook</span>(<span class="dt">int</span> isbn) {</span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="bu">String</span> json = rbs.<span class="fu">search</span>(isbn);</span>
<span id="cb16-13"><a href="#cb16-13"></a>    JSONObject obj = <span class="kw">new</span> <span class="fu">JSONObject</span>(json);</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="bu">String</span> titulo;</span>
<span id="cb16-15"><a href="#cb16-15"></a>    titulo = (<span class="bu">String</span>)obj.<span class="fu">get</span>(<span class="st">&quot;titulo&quot;</span>);</span>
<span id="cb16-16"><a href="#cb16-16"></a>    <span class="kw">return</span> <span class="kw">new</span> <span class="bu">Book</span>(titulo);</span>
<span id="cb16-17"><a href="#cb16-17"></a>  }</span>
<span id="cb16-18"><a href="#cb16-18"></a></span>
<span id="cb16-19"><a href="#cb16-19"></a>}</span>
<span id="cb16-20"><a href="#cb16-20"></a></span>
<span id="cb16-21"><a href="#cb16-21"></a><span class="kw">public</span> <span class="kw">interface</span> BookService {</span>
<span id="cb16-22"><a href="#cb16-22"></a>  <span class="bu">String</span> <span class="fu">search</span>(<span class="dt">int</span> isbn);</span>
<span id="cb16-23"><a href="#cb16-23"></a>}</span></code></pre></div>
<p><strong>Problema</strong>: Precisamos implementar um teste de unidade para <code>BookSearch</code>. Porém, por definição, um teste de unidade exercita um componente pequeno do código, como uma única classe. O problema é que para testar <code>BookSearch</code> precisamos de um <code>BookService</code>, que é um serviço externo. Ou seja, se não tomarmos cuidado, o teste de <code>getBook</code> vai alcançar um serviço externo. Isso é ruim por dois motivos: (1) o escopo do teste ficará maior do que uma única unidade de código; (2) o teste ficará mais lento, pois o serviço externo pode ser uma base de dados, armazenada em disco, ou então um serviço remoto, acessado via HTTP ou um protocolo similar. E devemos lembrar que testes de unidades devem executar rapidamente, conforme recomendado pelos princípios FIRST (Seção 8.3).</p>
<p><strong>Solução</strong>: Uma solução consiste em criar um objeto que <q>emula</q> o objeto real, mas apenas para permitir o teste do programa. Esse tipo de objeto é chamado de <strong>mock</strong> (ou então <strong>stub</strong>). No nosso exemplo, o mock deve implementar a interface <code>BookService</code> e, portanto, o método <code>search</code>. Porém, essa implementação é parcial, pois o mock retorna apenas os títulos de alguns livros, sem acessar servidores remotos ou bancos de dados. Um exemplo é mostrado a seguir:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.*;</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="kw">import</span><span class="im"> org.junit.*;</span></span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.*;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="kw">class</span> BookConst {</span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="bu">String</span> ESM = </span>
<span id="cb17-8"><a href="#cb17-8"></a>                <span class="st">&quot;{ </span><span class="sc">\&quot;</span><span class="st">titulo</span><span class="sc">\&quot;</span><span class="st">: </span><span class="sc">\&quot;</span><span class="st">Eng Soft Moderna</span><span class="sc">\&quot;</span><span class="st"> }&quot;</span>;        </span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="bu">String</span> NULLBOOK = <span class="st">&quot;NULL&quot;</span>;</span>
<span id="cb17-11"><a href="#cb17-11"></a></span>
<span id="cb17-12"><a href="#cb17-12"></a>}</span>
<span id="cb17-13"><a href="#cb17-13"></a></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="kw">class</span> MockBookService <span class="kw">implements</span> BookService {</span>
<span id="cb17-15"><a href="#cb17-15"></a></span>
<span id="cb17-16"><a href="#cb17-16"></a>   <span class="kw">public</span> <span class="bu">String</span> <span class="fu">search</span>(<span class="dt">int</span> isbn) {</span>
<span id="cb17-17"><a href="#cb17-17"></a>      <span class="kw">if</span> (isbn == <span class="dv">1234</span>)</span>
<span id="cb17-18"><a href="#cb17-18"></a>        <span class="kw">return</span> BookConst.<span class="fu">ESM</span>;</span>
<span id="cb17-19"><a href="#cb17-19"></a>      <span class="kw">return</span> BookConst.<span class="fu">NULLBOOK</span>;</span>
<span id="cb17-20"><a href="#cb17-20"></a>   }</span>
<span id="cb17-21"><a href="#cb17-21"></a></span>
<span id="cb17-22"><a href="#cb17-22"></a>}</span>
<span id="cb17-23"><a href="#cb17-23"></a></span>
<span id="cb17-24"><a href="#cb17-24"></a><span class="kw">public</span> <span class="kw">class</span> BookSearchTest {</span>
<span id="cb17-25"><a href="#cb17-25"></a></span>
<span id="cb17-26"><a href="#cb17-26"></a>  <span class="kw">private</span> BookService service;</span>
<span id="cb17-27"><a href="#cb17-27"></a></span>
<span id="cb17-28"><a href="#cb17-28"></a>  <span class="at">@Before</span></span>
<span id="cb17-29"><a href="#cb17-29"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>() {</span>
<span id="cb17-30"><a href="#cb17-30"></a>    service = <span class="kw">new</span> <span class="fu">MockBookService</span>();</span>
<span id="cb17-31"><a href="#cb17-31"></a>  }        </span>
<span id="cb17-32"><a href="#cb17-32"></a></span>
<span id="cb17-33"><a href="#cb17-33"></a>  <span class="at">@Test</span></span>
<span id="cb17-34"><a href="#cb17-34"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testGetBook</span>() {</span>
<span id="cb17-35"><a href="#cb17-35"></a>    BookSearch bs = <span class="kw">new</span> <span class="fu">BookSearch</span>(service);</span>
<span id="cb17-36"><a href="#cb17-36"></a>    <span class="bu">String</span> titulo = bs.<span class="fu">getBook</span>(<span class="dv">1234</span>).<span class="fu">getTitulo</span>();</span>
<span id="cb17-37"><a href="#cb17-37"></a>    <span class="fu">assertEquals</span>(<span class="st">&quot;Eng Soft Moderna&quot;</span>, titulo);</span>
<span id="cb17-38"><a href="#cb17-38"></a>  }</span>
<span id="cb17-39"><a href="#cb17-39"></a></span>
<span id="cb17-40"><a href="#cb17-40"></a>}</span></code></pre></div>
<p>Nesse exemplo, <code>MockBookService</code> é uma classe usada para criar mocks de <code>BookService</code>, isto é, objetos que implementam essa interface, mas com um comportamento trivial. No exemplo, o objeto mock, de nome <code>service</code>, somente retorna dados do livro cujo ISBN é 1234. O leitor pode então estar se perguntando: qual a utilidade de um serviço que pesquisa dados de um único livro? A resposta é que esse mock nos permite implementar um teste de unidade que não precisa acessar um serviço remoto, externo e lento. No método <code>testGetBook</code>, usa-se o mock para criar um objeto do tipo <code>BookSearch</code>. Em seguida, chama-se o método <code>getBook</code> para pesquisar por um livro e retornar o seu título. Por fim, executa-se um <code>assert</code>. Como o teste é baseado em um <code>MockBookService</code>, ele verifica se o título retornado é aquele do único livro <q>pesquisado</q> por tal mock.</p>
<p>Porém, talvez ainda reste uma pergunta: o que, de fato, <code>testGetBook</code> testa? Em outras palavras, qual requisito do sistema está sendo testado por meio de um objeto mock tão simples? Claro, nesse caso, não estamos testando o acesso ao serviço remoto. Como foi afirmado, esse é um requisito muito <q>extenso</q> para ser verificado via testes de unidade. Em vez disso, estamos testando se a lógica de instanciar um <code>Book</code> a partir de um documento JSON está funcionando. Em um teste mais real, poderíamos incluir mais campos em <code>Book</code>, além do título. Poderíamos também testar com mais alguns livros, bastando estender a capacidade do mock: em vez de retornar sempre o JSON do mesmo livro, ele retornaria dados de mais livros, dependendo do ISBN.</p>
<p><strong>Código Fonte</strong>: O código do exemplo de mock usado nesta seção está disponível neste <a href="https://gist.github.com/mtov/c162dce743cc2cb8fdbc25605c35cc2b">link</a>.</p>
<h3 data-number="1.6.1" id="frameworks-de-mocks" data-number="1.6.1"><span class="header-section-number">8.6.1</span> Frameworks de Mocks</h3>
<p>Mocks são tão comuns em testes de unidade que existem frameworks para facilitar a criação e <q>programação</q> de mocks (e/ou stubs). Não vamos entrar em detalhes desses frameworks, mas abaixo mostramos o teste anterior, mas com um mock instanciado por um framework chamado <strong>mockito</strong> (<a href="https://site.mockito.org/">link</a>), muito usado quando se escreve testes de unidade em Java que requerem mocks.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">import</span><span class="im"> org.junit.*;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">import static</span><span class="im"> org.junit.Assert.*;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="kw">import</span><span class="im"> org.mockito.Mockito;</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="kw">import static</span><span class="im"> org.mockito.Mockito.when;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="kw">import static</span><span class="im"> org.mockito.Matchers.anyInt;</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">public</span> <span class="kw">class</span> BookSearchTest {</span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a>  <span class="kw">private</span> BookService service;</span>
<span id="cb18-10"><a href="#cb18-10"></a></span>
<span id="cb18-11"><a href="#cb18-11"></a>  <span class="at">@Before</span></span>
<span id="cb18-12"><a href="#cb18-12"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>() {</span>
<span id="cb18-13"><a href="#cb18-13"></a>    service = Mockito.<span class="fu">mock</span>(BookService.<span class="fu">class</span>);</span>
<span id="cb18-14"><a href="#cb18-14"></a>    <span class="fu">when</span>(service.<span class="fu">search</span>(<span class="fu">anyInt</span>())).</span>
<span id="cb18-15"><a href="#cb18-15"></a>                 <span class="fu">thenReturn</span>(BookConst.<span class="fu">NULLBOOK</span>);</span>
<span id="cb18-16"><a href="#cb18-16"></a>    <span class="fu">when</span>(service.<span class="fu">search</span>(<span class="dv">1234</span>)).<span class="fu">thenReturn</span>(BookConst.<span class="fu">ESM</span>);</span>
<span id="cb18-17"><a href="#cb18-17"></a>  }        </span>
<span id="cb18-18"><a href="#cb18-18"></a></span>
<span id="cb18-19"><a href="#cb18-19"></a>  <span class="at">@Test</span></span>
<span id="cb18-20"><a href="#cb18-20"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testGetBook</span>() {</span>
<span id="cb18-21"><a href="#cb18-21"></a>    BookSearch bs = <span class="kw">new</span> <span class="fu">BookSearch</span>(service);</span>
<span id="cb18-22"><a href="#cb18-22"></a>    <span class="bu">String</span> titulo = bs.<span class="fu">getBook</span>(<span class="dv">1234</span>).<span class="fu">getTitulo</span>();</span>
<span id="cb18-23"><a href="#cb18-23"></a>    <span class="fu">assertEquals</span>(<span class="st">&quot;Eng Soft Moderna&quot;</span>, titulo);</span>
<span id="cb18-24"><a href="#cb18-24"></a>  }</span>
<span id="cb18-25"><a href="#cb18-25"></a></span>
<span id="cb18-26"><a href="#cb18-26"></a>}</span></code></pre></div>
<p>Primeiro, podemos ver que não existe mais uma classe <code>MockBookService</code>. O principal ganho de se usar um framework como o mockito é exatamente esse: não ter mais que escrever classes de mock manualmente. Em vez disso, um mock para <code>BookService</code> é criado pelo próprio framework usando-se dos recursos de <strong>reflexão computacional</strong> de Java. Para isso, basta usar a função <code>mock(type)</code>, como a seguir:</p>
<p><code>service = Mockito.mock(BookService.class);</code></p>
<p>No entanto, o mock <code>service</code> ainda está vazio e sem nenhum comportamento. Temos então que ensiná-lo a se comportar pelo menos em algumas situações. Especificamente, temos que ensiná-lo a responder a algumas pesquisas de livros. Para isso, o mockito oferece uma <strong>linguagem de domínio específico</strong> simples, baseada na mesma sintaxe de Java. Um exemplo é mostrado a seguir:</p>
<p><code>when(service.search(anyInt())).thenReturn(BookConst.NULLBOOK);</code></p>
<p><code>when(service.search(1234)).thenReturn(BookConst.ESM);</code></p>
<p>Essa duas linhas <q>programam</q> o mock <code>service</code>. Primeiro, dizemos para ele retornar <code>BookConst.NULLBOOK</code> quando o seu método <code>search</code> for chamado com qualquer inteiro como argumento. Em seguida, abrimos uma exceção a essa regra geral: quando <code>search</code> for chamado com o inteiro 1234, ele deve retornar a string JSON com os dados do livro <code>BookConst.ESM</code>.</p>
<p><strong>Código Fonte</strong>: O código desse exemplo, usando o mockito, está neste <a href="https://gist.github.com/mtov/f7781e3f164a62c85cf4294271b9c2fd">link</a>.</p>
<h3 data-number="1.6.2" id="mocks-vs-stubs" data-number="1.6.2"><span class="header-section-number">8.6.2</span> Mocks vs Stubs</h3>
<p>Alguns autores, como Martin Fowler (<a href="https://martinfowler.com/articles/mocksArentStubs.html">link</a>) e também Gerard Meszaros (<a href="https://dl.acm.org/citation.cfm?id=1076526">link</a>) fazem uma distinção entre <strong>mocks</strong> e <strong>stubs</strong>. Segundo eles, mocks devem verificar não apenas o estado do Sistema sob Testes (SUT), mas também o seu comportamento. Se os mocks verificam apenas o estado, eles deveriam ser chamados de stubs. No entanto, neste livro, não vamos fazer essa distinção, pois achamos que ela é sutil e, portanto, os benefícios não compensam o custo de páginas extras para explicar e diferenciar conceitos semelhantes. Porém, apenas para esclarecer um pouco mais, um <strong>teste comportamental</strong> verifica eventos que ocorreram no SUT. Um exemplo simples é o seguinte teste:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb19-1"><a href="#cb19-1"></a>testBehaviour {</span>
<span id="cb19-2"><a href="#cb19-2"></a>  Mailer m = <span class="fu">mock</span>(Mailer.<span class="fu">class</span>);</span>
<span id="cb19-3"><a href="#cb19-3"></a>  sut.<span class="fu">someBusinessLogic</span>(m);</span>
<span id="cb19-4"><a href="#cb19-4"></a>  <span class="fu">verify</span>(m).<span class="fu">send</span>(<span class="fu">anyString</span>());</span>
<span id="cb19-5"><a href="#cb19-5"></a>}</span></code></pre></div>
<p>Nesse exemplo, o comando <code>verify</code> — implementado pelo mockito — é parecido com um <code>assert</code>. No entanto, ele verifica se um evento ocorreu com o mock passado como argumento. No caso, verificamos se o método <code>send</code> do mock foi executado pelo menos uma vez, usando qualquer string como argumento.</p>
<p>Segundo Gerado Meszaros, mocks e stubs são casos especiais de <strong>objetos dublê</strong> (<em>double</em>). O termo é inspirado em dublês de atores em filmes. Segundo Meszaros, existem pelo menos mais dois outros tipos de objetos dublê:</p>
<ul>
<li><p><strong>Objetos Dummy</strong> são objetos que são passados como argumento para um método, mas que não são usados. Trata-se, portanto, de uma forma de dublê usada apenas para satisfazer o sistema de tipos da linguagem.</p></li>
<li><p><strong>Objeto Fake</strong> são objetos que possuem uma implementação mais simples do que o objeto real. Por exemplo, um objeto que simula em memória principal, por meio de tabelas hash, um objeto de acesso a bancos de dados.</p></li>
</ul>
<h3 data-number="1.6.3" id="exemplo-servlet-1" data-number="1.6.3"><span class="header-section-number">8.6.3</span> Exemplo: Servlet</h3>
<p>Na seção anterior, mostramos o teste de uma servlet que calcula o Índice de Massa Corporal (IMC) de uma pessoa. No entanto, argumentamos que não iríamos testar a servlet completa porque ela possui dependências difíceis de serem recriadas em um teste. No entanto, agora sabemos que podemos criar mocks para essas dependências, isto é, objetos que vão <q>simular</q> as dependências reais, porém respondendo apenas às chamadas que precisamos no teste.</p>
<p>Primeiro, vamos reapresentar o código da servlet que queremos testar:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">public</span> <span class="kw">class</span> IMCServlet <span class="kw">extends</span> HttpServlet {</span>
<span id="cb20-2"><a href="#cb20-2"></a></span>
<span id="cb20-3"><a href="#cb20-3"></a>  IMCModel model = <span class="kw">new</span> <span class="fu">IMCModel</span>();</span>
<span id="cb20-4"><a href="#cb20-4"></a></span>
<span id="cb20-5"><a href="#cb20-5"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">doGet</span>(HttpServletRequest req, </span>
<span id="cb20-6"><a href="#cb20-6"></a>                    HttpServletResponse res) {</span>
<span id="cb20-7"><a href="#cb20-7"></a>    res.<span class="fu">setContentType</span>(<span class="st">&quot;text/html&quot;</span>);</span>
<span id="cb20-8"><a href="#cb20-8"></a>    <span class="bu">PrintWriter</span> out = res.<span class="fu">getWriter</span>();</span>
<span id="cb20-9"><a href="#cb20-9"></a>    <span class="bu">String</span> peso = req.<span class="fu">getParameter</span>(<span class="st">&quot;peso&quot;</span>);</span>
<span id="cb20-10"><a href="#cb20-10"></a>    <span class="bu">String</span> altura = req.<span class="fu">getParameter</span>(<span class="st">&quot;altura&quot;</span>);</span>
<span id="cb20-11"><a href="#cb20-11"></a>    <span class="dt">double</span> imc = model.<span class="fu">calculaIMC</span>(peso,altura);</span>
<span id="cb20-12"><a href="#cb20-12"></a>    out.<span class="fu">println</span>(<span class="st">&quot;IMC: &quot;</span> + imc);</span>
<span id="cb20-13"><a href="#cb20-13"></a>  }</span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a>}</span></code></pre></div>
<p>Segue então o novo teste dessa servlet (ele é uma adaptação de um exemplo disponível em um <a href="https://doi.ieeecomputersociety.org/10.1109/MS.2002.1003449">artigo</a> de autoria de Dave Thomas e Andy Hunt). Primeiro, podemos ver, no método <code>init</code>, que foram criados mocks para objetos dos tipos <code>HttpServletRequest</code> e <code>HttpServletResponse</code>. Esses mocks serão usados como parâmetros da chamada de <code>doGet</code> que faremos no método de teste. Ainda em <code>init</code>, criamos um objeto do tipo <code>StringWriter</code> que permite gerar saídas na forma de uma lista de Strings. Em seguida, esse objeto é encapsulado por um <code>PrintWriter</code>, que é o objeto usado como saída pela servlet — ou seja, trata-se de uma aplicação padrão de projeto Decorador, que estudamos no Capítulo 6. Por fim, programamos o mock de resposta: quando a servlet pedir um objeto de saída, por meio de uma chamada a <code>getWriter()</code>, ele deve retornar o objeto <code>PrintWriter</code> que acabamos de criar. Em resumo, fizemos tudo isso com o objetivo de alterar a saída da servlet para uma lista de strings.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">public</span> <span class="kw">class</span> IMCServletTest {</span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a>  HttpServletRequest req;</span>
<span id="cb21-4"><a href="#cb21-4"></a>  HttpServletResponse res;</span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a>  <span class="bu">StringWriter</span> sw;</span>
<span id="cb21-7"><a href="#cb21-7"></a></span>
<span id="cb21-8"><a href="#cb21-8"></a>  <span class="at">@Before</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">init</span>() {</span>
<span id="cb21-10"><a href="#cb21-10"></a>    req = Mockito.<span class="fu">mock</span>(HttpServletRequest.<span class="fu">class</span>);</span>
<span id="cb21-11"><a href="#cb21-11"></a>    res = Mockito.<span class="fu">mock</span>(HttpServletResponse.<span class="fu">class</span>);</span>
<span id="cb21-12"><a href="#cb21-12"></a>    sw = <span class="kw">new</span> <span class="bu">StringWriter</span>();</span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="bu">PrintWriter</span> pw = <span class="kw">new</span> <span class="bu">PrintWriter</span>(sw);</span>
<span id="cb21-14"><a href="#cb21-14"></a>    <span class="fu">when</span>(res.<span class="fu">getWriter</span>()).<span class="fu">thenReturn</span>(pw);</span>
<span id="cb21-15"><a href="#cb21-15"></a>  }</span>
<span id="cb21-16"><a href="#cb21-16"></a>  <span class="co">// ...continua a seguir</span></span></code></pre></div>
<p>Para concluir, temos o método de teste, mostrado a seguir.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb22-1"><a href="#cb22-1"></a>  <span class="co">// continuação de IMCServletTest</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>  <span class="at">@Test</span></span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">testDoGet</span>() {</span>
<span id="cb22-4"><a href="#cb22-4"></a>    <span class="fu">when</span>(req.<span class="fu">getParameter</span>(<span class="st">&quot;peso&quot;</span>)).<span class="fu">thenReturn</span>(<span class="st">&quot;82&quot;</span>);</span>
<span id="cb22-5"><a href="#cb22-5"></a>    <span class="fu">when</span>(req.<span class="fu">getParameter</span>(<span class="st">&quot;altura&quot;</span>)).<span class="fu">thenReturn</span>(<span class="st">&quot;1.80&quot;</span>);</span>
<span id="cb22-6"><a href="#cb22-6"></a>    <span class="kw">new</span> <span class="fu">IMCServlet</span>().<span class="fu">doGet</span>(req,res);</span>
<span id="cb22-7"><a href="#cb22-7"></a>    <span class="fu">assertEquals</span>(<span class="st">&quot;IMC: 25.3</span><span class="sc">\n</span><span class="st">&quot;</span>, sw.<span class="fu">toString</span>());</span>
<span id="cb22-8"><a href="#cb22-8"></a>  }</span>
<span id="cb22-9"><a href="#cb22-9"></a></span>
<span id="cb22-10"><a href="#cb22-10"></a>}</span></code></pre></div>
<p>Nesse teste, começamos programando o mock do objeto com os parâmetros de entrada da servlet. Quando a servlet pedir o parâmetro <q>peso</q>, o mock vai retornar 82; quando a servlet pedir o parâmetro <q>altura</q>, ele deve retornar 1.80. Feito isso, o teste segue o fluxo normal de testes de unidades: chamamos o método que queremos testar, <code>doGet</code>, e verificamos se ele retorna o resultado esperado.</p>
<p>Esse exemplo serve também para ilustrar as desvantagens do uso de mocks. A principal delas é o fato de mocks aumentarem o acoplamento entre o teste e o método testado. Tipicamente, em testes de unidade, o método de teste chama o método testado e verifica seu resultado. Logo, ele se acopla apenas à assinatura deste método. Por isso, o teste não é <q>quebrado</q> quando apenas o código interno do método testado é modificado. No entanto, quando usamos mocks, isso deixa de ser verdade, pois o mock pode depender de estruturas internas do método testado, o que torna os testes mais frágeis. Por exemplo, suponha que a saída da servlet mude para <q>Índice de Massa Corporal (IMC):</q> [valor]. Nesse caso, teremos que lembrar de atualizar também o <code>assertEquals</code> do teste de unidade.</p>
<p>Por fim, não conseguimos criar mocks para todos objetos e métodos. Em geral, as seguintes construções não são <q>mockáveis</q>: classes e métodos finais, métodos estáticos e construtores.</p>
<p><strong>Código Fonte</strong>: O código do teste dessa servlet, usando mocks, está disponível neste <a href="https://gist.github.com/mtov/5372c7ffebe79c21768d0b1290c409b1">link</a>.</p>
<h2 data-number="1.7" id="desenvolvimento-dirigido-por-testes-tdd" data-number="1.7"><span class="header-section-number">8.7</span> Desenvolvimento Dirigido por Testes (TDD)</h2>
<p>Desenvolvimento Dirigido por Testes (<em>Test Driven Development</em>, TDD) é uma das práticas de programação propostas por Extreme Programming (XP). A ideia a princípio pode parecer estranha, talvez até absurda: dado um teste de unidade T para uma classe C, TDD defende que T deve ser escrito antes de C. Por isso, TDD é conhecido também como <em>Test-First Development</em>.</p>
<p>Quando se escreve o teste primeiro, ele vai falhar. Então, no fluxo de trabalho defendido por TDD, o próximo passo consiste em escrever o código que faz esse teste passar, mesmo que seja um código trivial. Em seguida, esse primeiro código deve ser finalizado e refinado. Por fim, se necessário, ele deve ser refatorado, para melhorar seu projeto, legibilidade, manutenibilidade, para seguir princípios e padrões de projeto, etc.</p>
<p>TDD foi proposto com três objetivos principais em mente:</p>
<ul>
<li><p>TDD ajuda a evitar que os desenvolvedores esqueçam de escrever testes. Para isso, TDD promove testes à primeira atividade de qualquer tarefa de programação, seja ela corrigir um bug ou implementar uma nova funcionalidade. Sendo a primeira atividade, é mais difícil que a escrita de testes seja deixada para um segundo momento.</p></li>
<li><p>TDD favorece a escrita de código com alta testabilidade. Essa característica é uma consequência natural da inversão do fluxo de trabalho proposta por TDD: como o desenvolvedor sabe que ele terá que escrever o teste T e depois a classe C, é natural que desde o início ele planeje C de forma a facilitar a escrita de seu teste. De fato, como mencionamos na Seção 8.4, sistemas que usam TDD têm alta cobertura de testes, normalmente acima de 90%.</p></li>
<li><p>TDD é uma prática relacionada não apenas com testes, mas também com a melhoria do design de um sistema. Isso acontece porque o desenvolvedor, ao começar pela escrita de um teste T, coloca-se na posição de um usuário da classe C. Em outras palavras, com TDD, o primeiro usuário da classe é seu próprio desenvolvedor — lembre que T é um cliente de C, pois ele chama métodos de C. Por isso, espera-se que o desenvolvedor simplifique a interface de C, use nomes de identificadores legíveis, evite muitos parâmetros, etc.</p></li>
</ul>
<p>Quando trabalha-se com TDD, o desenvolvedor segue um um ciclo composto por três estados, conforme mostra a próxima figura.</p>
<figure>
<img src="figs/cap8/ciclos-tdd.svg" style="width:75.0%" alt="" /><figcaption>Ciclos de TDD</figcaption>
</figure>
<p>De acordo com esse diagrama, a primeira meta é chegar no estado vermelho, quando o teste ainda não está passando. Pode parecer estranho, mas o estado vermelho já é uma pequena vitória: ao escrever um teste que falha, o desenvolvedor pelo menos tem em mãos uma especificação da classe que ele precisará implementar em seguida. Ou seja, ele já sabe o que tem que fazer. Conforme já mencionamos, nesse estado, é importante que o desenvolvedor pense também na interface da classe que ele terá que implementar, colocando-se na posição de um usuário da mesma. Por fim, é importante que ele entregue o código compilando. Para isso, ele deve escrever pelo menos o esqueleto da classe sob teste, isto é, a assinatura da classe e de seus métodos.</p>
<p>Em seguida, a meta é alcançar o estado verde. Para isso, deve-se implementar a funcionalidade completa da classe sob teste; quando isso ocorrer, os testes que estavam falhando vão começar a passar. No entanto, pode-se dividir essa implementação em pequenos passos. Talvez, nos passos iniciais, o código estará funcionando de forma parcial, por exemplo, retornando apenas constantes. Isso ficará mais claro no exemplo que daremos a seguir.</p>
<p>Por fim, deve-se analisar se existem oportunidades para refatorar o código da classe e do teste. Quando se usa TDD, o objetivo não é apenas alcançar o estado verde, no qual o programa está funcionando. Além disso, deve-se verificar a possibilidade de melhorar a qualidade do projeto do código. Por exemplo, verificar se não existe código duplicado, se não existem métodos muito longos que possam ser quebrados em métodos menores, se algum método pode ser movido para uma classe diferente, etc. Terminado o passo de refatoração, podemos parar ou então reiniciar o ciclo, para implementar mais alguma funcionalidade.</p>
<h3 data-number="1.7.1" id="exemplo-carrinho-de-compras" data-number="1.7.1"><span class="header-section-number">8.7.1</span> Exemplo: Carrinho de Compras</h3>
<p>Para concluir, vamos ilustrar uma sessão de uso de TDD. Para isso, usaremos como exemplo o sistema de uma livraria virtual. Nesse sistema, temos uma classe <code>Book</code>, com atributos <code>titulo</code>, <code>isbn</code> e <code>preco</code>. E temos também a classe <code>ShoppingCart</code>, que armazena os livros que um cliente deseja comprar. Essa classe deve implementar métodos para: adicionar um livro no carrinho; retornar o preço total dos livros no carrinho; e remover um livro do carrinho. A seguir, mostramos a implementação desses métodos usando TDD.</p>
<p><strong>Estado Vermelho:</strong> Começamos definindo que <code>ShoppingCart</code> terá um método <code>add</code> e um método <code>getTotal</code>. Além de decidir o nome de tais métodos, definimos os seus parâmetros e escrevemos o primeiro teste:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb23-1"><a href="#cb23-1"></a><span class="at">@Test</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="dt">void</span> <span class="fu">testAddGetTotal</span>() {</span>
<span id="cb23-3"><a href="#cb23-3"></a>  <span class="bu">Book</span> b1 = <span class="kw">new</span> <span class="bu">Book</span>(<span class="st">&quot;book1&quot;</span>, <span class="dv">10</span>, <span class="st">&quot;1&quot;</span>);</span>
<span id="cb23-4"><a href="#cb23-4"></a>  <span class="bu">Book</span> b2 = <span class="kw">new</span> <span class="bu">Book</span>(<span class="st">&quot;book2&quot;</span>, <span class="dv">20</span>, <span class="st">&quot;2&quot;</span>);</span>
<span id="cb23-5"><a href="#cb23-5"></a>  ShoppingCart cart = <span class="kw">new</span> <span class="fu">ShoppingCart</span>();</span>
<span id="cb23-6"><a href="#cb23-6"></a>  cart.<span class="fu">add</span>(b1);</span>
<span id="cb23-7"><a href="#cb23-7"></a>  cart.<span class="fu">add</span>(b2);</span>
<span id="cb23-8"><a href="#cb23-8"></a>  <span class="fu">assertEquals</span>(<span class="fl">30.</span><span class="dv">0</span>,cart.<span class="fu">getTotal</span>());</span>
<span id="cb23-9"><a href="#cb23-9"></a>}</span></code></pre></div>
<p>Apesar de simples e de fácil entendimento, esse teste ainda não compila, pois não existe implementação para as classes <code>Book</code> e <code>ShoppingCart</code>. Então, temos que providenciar isso, como mostrado a seguir:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">public</span> <span class="kw">class</span> <span class="bu">Book</span> {</span>
<span id="cb24-2"><a href="#cb24-2"></a>  <span class="kw">public</span> <span class="bu">String</span> title;</span>
<span id="cb24-3"><a href="#cb24-3"></a>  <span class="kw">public</span> <span class="dt">double</span> price;</span>
<span id="cb24-4"><a href="#cb24-4"></a>  <span class="kw">public</span> <span class="bu">String</span> isbn;</span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a>  <span class="kw">public</span> <span class="bu">Book</span>(<span class="bu">String</span> title, <span class="dt">double</span> price, <span class="bu">String</span> isbn) {</span>
<span id="cb24-7"><a href="#cb24-7"></a>    <span class="kw">this</span>.<span class="fu">title</span> = title;</span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="kw">this</span>.<span class="fu">price</span> = price;</span>
<span id="cb24-9"><a href="#cb24-9"></a>    <span class="kw">this</span>.<span class="fu">isbn</span> = isbn;</span>
<span id="cb24-10"><a href="#cb24-10"></a>  }</span>
<span id="cb24-11"><a href="#cb24-11"></a></span>
<span id="cb24-12"><a href="#cb24-12"></a>}</span>
<span id="cb24-13"><a href="#cb24-13"></a></span>
<span id="cb24-14"><a href="#cb24-14"></a><span class="kw">public</span> <span class="kw">class</span> ShoppingCart{</span>
<span id="cb24-15"><a href="#cb24-15"></a></span>
<span id="cb24-16"><a href="#cb24-16"></a>  <span class="kw">public</span> <span class="fu">ShoppingCart</span>() {}</span>
<span id="cb24-17"><a href="#cb24-17"></a></span>
<span id="cb24-18"><a href="#cb24-18"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="bu">Book</span> b) {}</span>
<span id="cb24-19"><a href="#cb24-19"></a></span>
<span id="cb24-20"><a href="#cb24-20"></a>  <span class="dt">double</span> <span class="fu">getTotal</span>() {</span>
<span id="cb24-21"><a href="#cb24-21"></a>    <span class="kw">return</span> <span class="fl">0.</span><span class="dv">0</span>;</span>
<span id="cb24-22"><a href="#cb24-22"></a>  }</span>
<span id="cb24-23"><a href="#cb24-23"></a>}</span></code></pre></div>
<p>A implementação de ambas as classes é muito simples. Implementamos apenas o mínimo para que o programa e o teste compilem. Observe, por exemplo, o método <code>getTotal</code> de <code>ShoppingCart</code>. Nessa implementação, ele sempre retorna 0.0. Apesar disso atingimos nosso objetivo: temos um teste compilando, executando e falhando! Ou seja, chegamos ao estado vermelho.</p>
<p><strong>Estado Verde</strong>: o teste anterior funciona como uma especificação. Isto é, ele define o que temos que implementar em <code>ShoppingCart</code>. Logo, mãos à obra:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">public</span> <span class="kw">class</span> ShoppingCart {</span>
<span id="cb25-2"><a href="#cb25-2"></a>  <span class="kw">public</span> <span class="fu">ShoppingCart</span>() {}</span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="bu">Book</span> b) {}</span>
<span id="cb25-4"><a href="#cb25-4"></a>  <span class="dt">double</span> <span class="fu">getTotal</span>() {</span>
<span id="cb25-5"><a href="#cb25-5"></a>    <span class="kw">return</span> <span class="fl">30.</span><span class="dv">0</span>;</span>
<span id="cb25-6"><a href="#cb25-6"></a>  }</span>
<span id="cb25-7"><a href="#cb25-7"></a>}</span></code></pre></div>
<p>Porém, o leitor deve estar agora surpreso: essa implementação está incorreta! A construtora de <code>ShoppingCart</code> está vazia, a classe não possui nenhuma estrutura de dados para armazenar os itens do carrinho, <code>getTotal</code> retorna sempre 30.0, etc. Tudo isso é verdade, mas já temos uma nova pequena vitória: o teste mudou de cor, de vermelho para verde. Ou seja, ele está passando. Com TDD, os avanços são sempre pequenos. Em XP, esses avanços são chamados de <strong>baby steps</strong>.</p>
<p>Mas temos que prosseguir e dar uma implementação mais realista para <code>ShoppingCart</code>. Segue então ela:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">public</span> <span class="kw">class</span> ShoppingCart {</span>
<span id="cb26-2"><a href="#cb26-2"></a></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="kw">private</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Book</span>&gt; items;</span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="kw">private</span> <span class="dt">double</span> total;</span>
<span id="cb26-6"><a href="#cb26-6"></a></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="kw">public</span> <span class="fu">ShoppingCart</span>() {</span>
<span id="cb26-8"><a href="#cb26-8"></a>    items = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Book</span>&gt;();  </span>
<span id="cb26-9"><a href="#cb26-9"></a>    total = <span class="fl">0.</span><span class="dv">0</span>;  </span>
<span id="cb26-10"><a href="#cb26-10"></a>  }</span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a>  <span class="kw">public</span> <span class="dt">void</span> <span class="fu">add</span>(<span class="bu">Book</span> b) {</span>
<span id="cb26-13"><a href="#cb26-13"></a>    items.<span class="fu">add</span>(b);</span>
<span id="cb26-14"><a href="#cb26-14"></a>    total += b.<span class="fu">price</span>();</span>
<span id="cb26-15"><a href="#cb26-15"></a>  }</span>
<span id="cb26-16"><a href="#cb26-16"></a></span>
<span id="cb26-17"><a href="#cb26-17"></a>  <span class="dt">double</span> <span class="fu">getTotal</span>() {</span>
<span id="cb26-18"><a href="#cb26-18"></a>    <span class="kw">return</span> total;</span>
<span id="cb26-19"><a href="#cb26-19"></a>  }</span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a>}</span></code></pre></div>
<p>Agora dispomos de uma estrutura de dados para armazenar os itens do carrinho, um atributo para armazenar o valor total do carrinho, uma classe construtora, um método <code>add</code> que adiciona os livros na estrutura de dados e incrementa o <code>total</code> do carrinho e assim por diante. No melhor do nosso juízo, essa implementação já implementa o que foi pedido e, por isso, podemos declarar que chegamos ao estado verde.</p>
<p><strong>Estado de refatoração</strong>: agora temos que olhar para o código que foi implementado — um teste e duas classes — e colocar em prática as propriedades, princípios e padrões de projeto que aprendemos em capítulos anteriores. Ou seja: existe alguma coisa que podemos fazer para tornar esse código mais legível, fácil de entender e de manter? No caso, a ideia que pode surgir é encapsular os campos de <code>Book</code>. Todos eles atualmente são públicos e, por isso, seria melhor implementar apenas métodos get e set para dar acesso a eles. Como essa implementação é simples, não vamos mostrar o código refatorado de <code>Book</code>.</p>
<p>Então, fechamos uma volta no ciclo vermelho-verde-refatorar de TDD. Agora, podemos parar ou então pensar em implementar mais um requisito. Por exemplo, podemos implementar um método para remover livros do carrinho. Para isso, temos que começar mais um ciclo.</p>
<h2 data-number="1.8" id="testes-de-integração" data-number="1.8"><span class="header-section-number">8.8</span> Testes de Integração</h2>
<p>Com testes de integração — também chamados de <strong>testes de serviços</strong> — subimos para um nível intermediário da pirâmide de testes (veja uma figura com essa pirâmide na primeira seção do capítulo). Assim, o objetivo deixa de ser o teste de uma unidade pequena de código, como uma classe apenas. Em vez disso, testes de integração exercitam um serviço completo, isto é, uma funcionalidade de maior granularidade do sistema. Por isso, eles envolvem mais classes, às vezes de pacotes distintos. Também envolvem dependências e sistemas reais, como bancos de dados e serviços remotos. Além disso, quando se implementa testes de integração não faz mais sentido usar mocks ou stubs. Como são testes maiores, eles levam mais tempo para executar e, consequentemente, são chamados com menor frequência.</p>
<h3 class="unnumbered" data-number="" id="exemplo-agenda-de-compromissos" class="unnumbered" data-number="">Exemplo: Agenda de Compromissos</h3>
<p>Suponha uma agenda simples que permita adicionar, remover e editar compromissos, conforme ilustrado na próxima figura.</p>
<figure>
<img src="figs/cap8/myappointments.png" style="width:60.0%" alt="" /><figcaption>Interface da Agenda de Compromissos</figcaption>
</figure>
<p>Nesse sistema, existe uma classe com métodos para manipular a agenda, como mostrado a seguir:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">public</span> <span class="kw">class</span> AgendaFacade{</span>
<span id="cb27-2"><a href="#cb27-2"></a>  <span class="dt">int</span> <span class="fu">addAppointment</span>(Appointment p);</span>
<span id="cb27-3"><a href="#cb27-3"></a>  <span class="dt">void</span> <span class="fu">removeAppointment</span>(<span class="dt">int</span> id);</span>
<span id="cb27-4"><a href="#cb27-4"></a>  <span class="dt">void</span> <span class="fu">editAppointment</span>(<span class="dt">int</span> id);</span>
<span id="cb27-5"><a href="#cb27-5"></a>  Appointmemt[] <span class="fu">listAppointments</span>();</span>
<span id="cb27-6"><a href="#cb27-6"></a>}</span></code></pre></div>
<p>Assim, podemos escrever o seguinte teste de integração para essa classe:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb28-1"><a href="#cb28-1"></a><span class="at">@Test</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="dt">void</span> <span class="fu">AgendaFacadeTest</span>() {</span>
<span id="cb28-3"><a href="#cb28-3"></a>  DB db = DB.<span class="fu">create</span>();</span>
<span id="cb28-4"><a href="#cb28-4"></a>  AgendaFacade agenda = <span class="kw">new</span> <span class="fu">AgendaFacade</span>();</span>
<span id="cb28-5"><a href="#cb28-5"></a>  Appointment app1 = <span class="kw">new</span> <span class="fu">Appointmemt</span>(...);</span>
<span id="cb28-6"><a href="#cb28-6"></a>  Appointment app2 = <span class="kw">new</span> <span class="fu">Appointmemt</span>(...);</span>
<span id="cb28-7"><a href="#cb28-7"></a>  Appointment app3 = <span class="kw">new</span> <span class="fu">Appointmemt</span>(...);</span>
<span id="cb28-8"><a href="#cb28-8"></a>  <span class="dt">int</span> id1 = agenda.<span class="fu">addAppointmemt</span>(app1);</span>
<span id="cb28-9"><a href="#cb28-9"></a>  <span class="dt">int</span> id2 = agenda.<span class="fu">addAppointmemt</span>(app2);</span>
<span id="cb28-10"><a href="#cb28-10"></a>  <span class="dt">int</span> id3 = agenda.<span class="fu">addAppointmemt</span>(app3);</span>
<span id="cb28-11"><a href="#cb28-11"></a>  Appointment [] apps = agenda.<span class="fu">listAppointments</span>();</span>
<span id="cb28-12"><a href="#cb28-12"></a>  <span class="fu">assertEquals</span>(<span class="dv">3</span>,apps.<span class="fu">length</span>);</span>
<span id="cb28-13"><a href="#cb28-13"></a>}</span></code></pre></div>
<p>Vale a pena mencionar dois pontos sobre esse teste. Primeiro, ele é implementado usando o JUnit, como os testes anteriores, de unidade, que estudamos neste capítulo. Ou seja, JUnit poder ser usado tanto para testes de unidade como para testes de integração. Segundo, ele é um teste de integração, pois a classe é testada com dependências reais, no caso para um banco de dados. No início do teste, cria-se um banco de dados com todas as tabelas vazias. Em seguida, três objetos são persistidos e depois lidos do banco de dados. Por fim, chama-se um <code>assert</code>. Assim, esse teste exercita os principais serviços da agenda, exceto aqueles relacionados com sua interface gráfica. Por isso, ele ainda não é um teste de sistema.</p>
<h2 data-number="1.9" id="testes-de-sistema" data-number="1.9"><span class="header-section-number">8.9</span> Testes de Sistema</h2>
<p>Testes de sistema estão posicionados no topo da pirâmide de testes. Trata-se de testes que simulam o uso de um sistema por um usuário real. Testes de sistema são também chamados de testes <strong>ponta-a-ponta</strong> (<em>end-to-end</em>) ou então <strong>testes de interfaces</strong>. São os testes mais caros, que demandam maior esforço para implementação e que executam em mais tempo.</p>
<h3 data-number="1.9.1" id="exemplo-teste-de-sistemas-web" data-number="1.9.1"><span class="header-section-number">8.9.1</span> Exemplo: Teste de Sistemas Web</h3>
<p>Selenium é um framework para automatizar testes de sistemas Web. O framework permite criar programas que funcionam como robôs que abrem páginas Web, preenchem formulários, clicam em botões, testam respostas, etc. Um exemplo — extraído e adaptado da documentação do Selenium (<a href="https://www.seleniumhq.org/docs/03_webdriver.jsp">link</a>) — é mostrado a seguir. Esse código simula um usuário de um navegador Firefox fazendo uma pesquisa no Google pela palavra <q>software</q>. O código também imprime na console o título da página que lista os resultados da pesquisa.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">public</span> <span class="kw">class</span> SeleniumExample {</span>
<span id="cb29-2"><a href="#cb29-2"></a></span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
<span id="cb29-4"><a href="#cb29-4"></a>    <span class="co">// cria um driver para acessar um servidor Web</span></span>
<span id="cb29-5"><a href="#cb29-5"></a>    WebDriver driver = <span class="kw">new</span> <span class="fu">FirefoxDriver</span>();</span>
<span id="cb29-6"><a href="#cb29-6"></a></span>
<span id="cb29-7"><a href="#cb29-7"></a>    <span class="co">// instrui o driver para &quot;navegar&quot; pela página do Google</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>    driver.<span class="fu">navigate</span>().<span class="fu">to</span>(<span class="st">&quot;http://www.google.com&quot;</span>);</span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a>    <span class="co">// obtém um campo de entrada de dados, de nome &quot;q&quot;</span></span>
<span id="cb29-11"><a href="#cb29-11"></a>    WebElement element = driver.<span class="fu">findElement</span>(By.<span class="fu">name</span>(<span class="st">&quot;q&quot;</span>));</span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a>    <span class="co">// preenche esse campo com as palavras &quot;software&quot;</span></span>
<span id="cb29-14"><a href="#cb29-14"></a>    element.<span class="fu">sendKeys</span>(<span class="st">&quot;software&quot;</span>);</span>
<span id="cb29-15"><a href="#cb29-15"></a></span>
<span id="cb29-16"><a href="#cb29-16"></a>    <span class="co">// submete os dados; como se fosse dado um &quot;enter&quot; no campo</span></span>
<span id="cb29-17"><a href="#cb29-17"></a>    element.<span class="fu">submit</span>();</span>
<span id="cb29-18"><a href="#cb29-18"></a></span>
<span id="cb29-19"><a href="#cb29-19"></a>    <span class="co">// espera a página de resposta carregar (com timeout de 8s)</span></span>
<span id="cb29-20"><a href="#cb29-20"></a>    (<span class="kw">new</span> <span class="fu">WebDriverWait</span>(driver,<span class="dv">8</span>)).</span>
<span id="cb29-21"><a href="#cb29-21"></a>         <span class="fu">until</span>(<span class="kw">new</span> ExpectedCondition&lt;<span class="bu">Boolean</span>&gt;() {</span>
<span id="cb29-22"><a href="#cb29-22"></a>     <span class="kw">public</span> <span class="bu">Boolean</span> <span class="fu">apply</span>(WebDriver d) {</span>
<span id="cb29-23"><a href="#cb29-23"></a>      <span class="kw">return</span> d.<span class="fu">getTitle</span>().<span class="fu">toLowerCase</span>().<span class="fu">startsWith</span>(<span class="st">&quot;software&quot;</span>);</span>
<span id="cb29-24"><a href="#cb29-24"></a>     }</span>
<span id="cb29-25"><a href="#cb29-25"></a>    });</span>
<span id="cb29-26"><a href="#cb29-26"></a></span>
<span id="cb29-27"><a href="#cb29-27"></a>    <span class="co">// resultado deve ser: &quot;software - Google Search&quot;</span></span>
<span id="cb29-28"><a href="#cb29-28"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;Page title is: &quot;</span> + driver.<span class="fu">getTitle</span>());</span>
<span id="cb29-29"><a href="#cb29-29"></a></span>
<span id="cb29-30"><a href="#cb29-30"></a>    <span class="co">// fecha o navegador</span></span>
<span id="cb29-31"><a href="#cb29-31"></a>    driver.<span class="fu">quit</span>();</span>
<span id="cb29-32"><a href="#cb29-32"></a>  }</span>
<span id="cb29-33"><a href="#cb29-33"></a>}</span></code></pre></div>
<p>Testes de interface são mais difíceis de escrever, pelo menos do que testes de unidade e mesmo do que testes de integração. Por exemplo, a API do Selenium é mais complexa do que aquela do JUnit. Além disso, o teste deve tratar eventos de interfaces, como timeouts que ocorrem quando uma página demora mais tempo do que o usual para ser carregada. Testes de interface também são mais frágeis, isto é, eles podem quebrar devido a pequenas mudanças na interface. Por exemplo, se o nome do campo de pesquisa da tela principal do Google mudar, o teste acima terá que ser atualizado. Porém, se compararmos com a alternativa — realizar o teste manualmente — eles ainda são competitivos e apresentam ganhos.</p>
<h3 data-number="1.9.2" id="exemplo-teste-de-um-compilador" data-number="1.9.2"><span class="header-section-number">8.9.2</span> Exemplo: Teste de um Compilador</h3>
<p>Quando desenvolve-se um compilador, pode-se usar testes de unidade ou de integração. Já os testes de sistema de um compilador tendem a ser conceitualmente mais simples. O motivo é que a interface de um compilador não inclui janelas e telas com elementos gráficos. Em vez disso, um compilador recebe um arquivo de entrada e produz um arquivo de saída. Assim, o teste de sistema de um compilador C para uma linguagem X demanda a implementação de vários programas em X, exercitando diversos aspectos dessa linguagem. Para cada programa P, deve-se definir um conjunto de dados de entrada e um conjunto de dados de saída. Preferencialmente, essa saída deve ser em um formato simples, como uma lista de strings. Então, o teste de sistema do compilador ocorre da seguinte forma: chama-se C para compilar cada programa P; em seguida, executamos o resultado da compilação com a entrada definida anteriormente e verificamos se o resultado é o esperado. Esse teste é um teste de sistema, pois estamos exercitando todas as funcionalidades do compilador.</p>
<p>Quando comparados com testes de unidade, é mais difícil localizar o trecho de código responsável por uma falha em testes de sistema. Por exemplo, no caso do compilador, teremos a indicação de que um programa não está executando corretamente. Porém, normalmente não é trivial mapear essa falha para a unidade do compilador que gerou código de forma incorreta.</p>
<h2 data-number="1.10" id="outros-tipos-de-testes" data-number="1.10"><span class="header-section-number">8.10</span> Outros Tipos de Testes</h2>
<h3 data-number="1.10.1" id="testes-caixa-preta-e-caixa-branca" data-number="1.10.1"><span class="header-section-number">8.10.1</span> Testes Caixa Preta e Caixa Branca</h3>
<p>Técnicas de teste podem ser classificadas como caixa preta ou caixa branca. Quando se usa uma <strong>técnica caixa preta</strong>, os testes são escritos com base apenas na interface do sistema sob testes. Por exemplo, se a missão for testar um método como uma caixa preta, a única informação disponível incluirá seu nome, parâmetros, tipos e exceções de retorno. Por outro lado, quando se usa uma <strong>técnica caixa branca</strong>, a escrita dos testes considera informações sobre o código e a estrutura do sistema sob teste. Por isso, técnicas de teste caixa preta são também chamadas de <strong>testes funcionais</strong>. E técnicas caixa branca são chamadas de <strong>testes estruturais</strong>.</p>
<p>No entanto, não é trivial classificar testes de unidade em uma dessas categorias. Na verdade, a classificação vai depender de como os testes são escritos. Se os testes de unidade forem escritos usando-se informações apenas sobre a interface dos métodos sob teste, eles são considerados como caixa preta. Porém, se a escrita considerar informações sobre a cobertura dos testes, desvios que são cobertos ou não, etc, então eles são testes caixa branca. Em resumo, testes de unidade sempre testam uma unidade pequena e isolada de código. Essa unidade pode ser testada na forma de uma caixa preta (conhecendo-se apenas a sua interface e requisitos externos) ou na forma de uma caixa branca (conhecendo-se e tirando-se proveito da sua estrutura interna, para elaboração de testes mais efetivos).</p>
<p>Uma observação semelhante pode ser feita sobre a relação entre TDD e testes caixa preta/branca. Para esclarecer essa relação, vamos usar algumas frases do do próprio Kent Beck, isto é, do inventor da ideia de TDD (fonte: <em>Test-Driven Development Violates the Dichotomies of Testing, Kent Beck</em>, Three Rivers Institute, June 2007):</p>
<blockquote>
<p><q>No contexto de TDD, uma dicotomia incorreta ocorre entre testes caixa preta e testes caixa branca. Como testes em TDD são escritos antes do código que eles testam, eles talvez pudessem ser considerados como testes caixa preta. No entanto, eu normalmente ganho inspiração para escrever o próximo teste depois que implemento e analiso o código verificado pelo teste anterior, o que é uma característica marcante de testes caixa branca.</q></p>
</blockquote>
<h3 data-number="1.10.2" id="seleção-de-dados-de-teste" data-number="1.10.2"><span class="header-section-number">8.10.2</span> Seleção de Dados de Teste</h3>
<p>Quando se adota testes caixa preta existem técnicas para auxiliar na seleção das entradas que serão verificadas no teste. Partição via <strong>Classe de Equivalência</strong> é uma técnica que recomenda dividir as entradas de um problema em conjuntos de valores que têm a mesma chance de apresentar um bug. Esses conjuntos são chamados de classes de equivalência. Para cada classe de equivalência, recomenda-se testar apenas um dos seus valores, que pode ser escolhido randomicamente. Suponha uma função para calcular o valor a pagar de imposto de renda, para cada faixa de salário, conforme tabela a seguir. Particionamento via classe de equivalência recomendaria testar essa função com quatro salários, um de cada faixa salarial.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Salário</strong></th>
<th style="text-align: left;"><strong>Alíquota</strong></th>
<th style="text-align: left;"><strong>Parcela a Deduzir</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">De 1.903,99 até 2.826,65</td>
<td style="text-align: left;">7,5%</td>
<td style="text-align: left;">142,80</td>
</tr>
<tr class="even">
<td style="text-align: left;">De 2.826,66 até 3.751,05</td>
<td style="text-align: left;">15%</td>
<td style="text-align: left;">354,80</td>
</tr>
<tr class="odd">
<td style="text-align: left;">De 3.751,06 até 4.664,68</td>
<td style="text-align: left;">22,5%</td>
<td style="text-align: left;">636,13</td>
</tr>
<tr class="even">
<td style="text-align: left;">Acima de 4.664,68</td>
<td style="text-align: left;">27,5%</td>
<td style="text-align: left;">869,36</td>
</tr>
</tbody>
</table>
<p><strong>Análise de Valor Limite</strong> (<em>Boundary Value Analysis</em>) é uma técnica complementar que recomenda testar uma unidade com os valores limites de cada classe de equivalência e seus valores subsequentes (ou antecedentes). O motivo é que bugs com frequência são causados por um tratamento inadequado desses valores de fronteira. Assim, no nosso exemplo, para a primeira faixa salarial, deveríamos testar com os seguintes valores:</p>
<ul>
<li>1.903,98: valor imediatamente inferior ao limite inferior da 1a faixa salarial</li>
<li>1.903,99: limite inferior da primeira faixa salarial</li>
<li>2.826,65: limite superior da primeira faixa salarial</li>
<li>2.826,66: valor imediatamente superior ao limite superior da 1a faixa salarial</li>
</ul>
<p>No entanto, como o leitor deve estar pensando, nem sempre é trivial encontrar as classes de equivalência para o domínio de entrada de uma função. Isto é, nem sempre todos os requisitos de um sistema são organizados em faixas de valores bem definidas como aquelas de nosso exemplo.</p>
<p>Para concluir, gostaríamos de lembrar que <strong>testes exaustivos</strong>, isto é, testar um programa com todas as entradas possíveis, na prática, é impossível, mesmo em programas pequenos. Por exemplo, imagine um compilador de uma linguagem X. É impossível testar esse compilador com todos os programas que podem ser implementados em X, até porque o número deles é infinito. Na verdade, mesmo uma função com apenas dois inteiros como parâmetro pode levar séculos para ser testada exaustivamente com todos os possíveis pares de inteiros. <strong>Testes randômicos</strong>, quando os dados de teste são escolhidos aleatoriamente, também não são recomendados, na maioria dos casos. O motivo é que pode-se selecionar diferentes valores de uma mesma classe de equivalência, o que não é necessário. Por outro lado, algumas classes de equivalência podem ficar sem testes.</p>
<h3 data-number="1.10.3" id="testes-de-aceitação" data-number="1.10.3"><span class="header-section-number">8.10.3</span> Testes de Aceitação</h3>
<p>São testes realizados pelo cliente, com dados do cliente. Os resultados desse teste irão determinar se o cliente está de acordo ou não com a implementação realizada. Se estiver de acordo, o sistema pode entrar em produção. Se não estiver de acordo, os devidos ajustes devem ser realizados. Por exemplo, quando se usa métodos ágeis, uma história somente é considerada completa após passar por testes de aceitação, realizados pelos usuários, ao final de um sprint.</p>
<p>Testes de aceitação possuem duas características que os distinguem de todos os testes que estudamos antes neste capítulo. Primeiro, são <strong>testes manuais</strong>, realizados pelos clientes finais do sistema. Segundo, eles não constituem exclusivamente uma atividade de verificação (como os testes anteriores), mas também uma atividade de validação do sistema. Lembre-se do capítulo de Introdução: verificação testa se fizemos o sistema corretamente, isto é, de acordo com a sua especificação e/ou requisitos. Já validação testa se fizemos o sistema correto, isto é, aquele que o cliente pediu e precisa.</p>
<p>Em alguns casos, testes de aceitação podem ser divididos em duas fases. <strong>Testes alfa</strong> são realizados com alguns usuários, mas em um ambiente controlado, como a própria máquina do desenvolvedor. Se o sistema for aprovado nos testes alfa, pode-se realizar um teste com um grupo maior de usuários e não mais em um ambiente controlado. Esses testes são chamados de <strong>testes beta</strong>.</p>
<h3 data-number="1.10.4" id="testes-de-requisitos-não-funcionais" data-number="1.10.4"><span class="header-section-number">8.10.4</span> Testes de Requisitos Não-Funcionais</h3>
<p>Os testes anteriores, com exceção dos testes de aceitação, verificam apenas requisitos funcionais; logo, eles têm como objetivo encontrar bugs. Porém, é possível realizar também testes para verificar ou validar requisitos não-funcionais. Por exemplo, existem ferramentas que permitem a realização de <strong>testes de desempenho</strong>, para verificar o comportamento de um sistema com alguma carga. Uma empresa de comércio eletrônico pode usar uma dessas ferramentas para simular o desempenho de seu site durante um grande evento, como uma Black-Friday, por exemplo. Já <strong>testes de usabilidade</strong> são usados para avaliar a interface do sistema e, normalmente, envolvem a observação de usuários reais usando o sistema. <strong>Testes de falhas</strong> simulam eventos anormais em um sistema, por exemplo a queda de alguns serviços ou mesmo de um data-center inteiro.</p>
<h2 class="unnumbered" data-number="" id="bibliografia" class="unnumbered" data-number="">Bibliografia</h2>
<p>Gerard Meszaros. xUnit Test Patterns: Refactoring Test Code. Addison-Wesley, 2007.</p>
<p>Kent Beck, Erich Gamma. Test-infected: programmers love writing tests. Java Report, 3(7):37-50, 1998.</p>
<p>Kent Beck. Test-Driven Development: by Example, Addison-Wesley, 2002.</p>
<p>Dave Thomas and Andy Hunt. Mock Objects. IEEE Software, 2002</p>
<p>Maurício Aniche. Testes automatizados de software: um guia prático. Casa do Código, 2015.</p>
<p>Jeff Langr, Andy Hunt, Dave Thomas. Pragmatic Unit Testing in Java 8 with Junit. O’Reilly, 2015.</p>
<h2 class="unnumbered" data-number="" id="exercícios-de-fixação" class="unnumbered" data-number="">Exercícios de Fixação</h2>
<p>1. (ENADE 2011) Uma equipe está realizando testes com o código-fonte de um sistema. Os testes envolvem a verificação de diversos componentes individualmente, bem como das interfaces entre eles. Essa equipe está realizando testes de:</p>
<ol type="a">
<li>unidade</li>
<li>aceitação</li>
<li>sistema e aceitação</li>
<li>integração e sistema</li>
<li>unidade e integração</li>
</ol>
<p>2. Descreva três benefícios associados ao uso de testes de unidade.</p>
<p>3. Suponha uma função <code>fib(n)</code>, que retorna o n-ésimo termo da sequência de Fibonacci, isto é, <code>fib(0) = 0</code>, <code>fib(1) = 1</code>, <code>fib(2) = 1</code>, <code>fib(3) = 2</code>, <code>fib(4) = 3</code>, etc. Escreva um teste de unidade para essa função.</p>
<p>4. Reescreva o seguinte teste, que verifica o levantamento de uma exceção <code>EmptyStackException</code>, para que ele fique mais simples e fácil de entender.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb30-1"><a href="#cb30-1"></a><span class="at">@Test</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">testEmptyStackException</span>() {</span>
<span id="cb30-3"><a href="#cb30-3"></a>  <span class="dt">boolean</span> sucesso = <span class="kw">false</span>;</span>
<span id="cb30-4"><a href="#cb30-4"></a>  <span class="kw">try</span>{</span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="bu">Stack</span> s&lt;<span class="bu">Integer</span>&gt; = <span class="kw">new</span> <span class="bu">Stack</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb30-6"><a href="#cb30-6"></a>    s.<span class="fu">push</span>(<span class="dv">10</span>);</span>
<span id="cb30-7"><a href="#cb30-7"></a>    <span class="dt">int</span> r = stack.<span class="fu">pop</span>();</span>
<span id="cb30-8"><a href="#cb30-8"></a>    r = stack.<span class="fu">pop</span>();</span>
<span id="cb30-9"><a href="#cb30-9"></a>  } <span class="kw">catch</span> (<span class="bu">EmptyStackException</span> e) {</span>
<span id="cb30-10"><a href="#cb30-10"></a>    sucesso = <span class="kw">true</span>;</span>
<span id="cb30-11"><a href="#cb30-11"></a>  }</span>
<span id="cb30-12"><a href="#cb30-12"></a>  <span class="fu">assertTrue</span>(sucesso);</span>
<span id="cb30-13"><a href="#cb30-13"></a>}</span></code></pre></div>
<p>5. Suponha que um programador escreveu o teste a seguir para a classe <code>ArrayList</code> de Java. Como você irá perceber, no código são usados diversos <code>System.out.println</code>. Ou seja, no fundo, ele é um teste manual, pois o desenvolvedor tem que conferir o seu resultado manualmente. Reescreva então cada um dos testes (de 1 a 6) como um teste de unidade, usando a sintaxe e os comandos do JUnit. Observação: se quiser executar o código, ele está disponível neste <a href="https://gist.github.com/mtov/11d9dce2bd37fe462003992835ebb1ba">link</a>.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">import</span><span class="im"> java.util.List;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">import</span><span class="im"> java.util.ArrayList;</span></span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="kw">public</span> <span class="kw">class</span> Main{</span>
<span id="cb31-5"><a href="#cb31-5"></a></span>
<span id="cb31-6"><a href="#cb31-6"></a>  <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span>(<span class="bu">String</span>[] args) {</span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a>    <span class="co">// teste 1  </span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="bu">List</span>&lt;<span class="bu">Integer</span>&gt; s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-10"><a href="#cb31-10"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">isEmpty</span>());</span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a>    <span class="co">// teste 2</span></span>
<span id="cb31-13"><a href="#cb31-13"></a>    s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-14"><a href="#cb31-14"></a>    s.<span class="fu">add</span>(<span class="dv">1</span>);</span>
<span id="cb31-15"><a href="#cb31-15"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">isEmpty</span>());</span>
<span id="cb31-16"><a href="#cb31-16"></a></span>
<span id="cb31-17"><a href="#cb31-17"></a>    <span class="co">// teste 3</span></span>
<span id="cb31-18"><a href="#cb31-18"></a>    s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-19"><a href="#cb31-19"></a>    s.<span class="fu">add</span>(<span class="dv">1</span>);</span>
<span id="cb31-20"><a href="#cb31-20"></a>    s.<span class="fu">add</span>(<span class="dv">2</span>);</span>
<span id="cb31-21"><a href="#cb31-21"></a>    s.<span class="fu">add</span>(<span class="dv">3</span>);</span>
<span id="cb31-22"><a href="#cb31-22"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">size</span>());</span>
<span id="cb31-23"><a href="#cb31-23"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">get</span>(<span class="dv">0</span>));</span>
<span id="cb31-24"><a href="#cb31-24"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">get</span>(<span class="dv">1</span>));</span>
<span id="cb31-25"><a href="#cb31-25"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">get</span>(<span class="dv">2</span>));</span>
<span id="cb31-26"><a href="#cb31-26"></a></span>
<span id="cb31-27"><a href="#cb31-27"></a>    <span class="co">// teste 4</span></span>
<span id="cb31-28"><a href="#cb31-28"></a>    s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-29"><a href="#cb31-29"></a>    s.<span class="fu">add</span>(<span class="dv">1</span>);</span>
<span id="cb31-30"><a href="#cb31-30"></a>    s.<span class="fu">add</span>(<span class="dv">2</span>);</span>
<span id="cb31-31"><a href="#cb31-31"></a>    s.<span class="fu">add</span>(<span class="dv">3</span>);</span>
<span id="cb31-32"><a href="#cb31-32"></a>    <span class="dt">int</span> elem = s.<span class="fu">remove</span>(<span class="dv">2</span>);</span>
<span id="cb31-33"><a href="#cb31-33"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(elem);</span>
<span id="cb31-34"><a href="#cb31-34"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">get</span>(<span class="dv">0</span>));</span>
<span id="cb31-35"><a href="#cb31-35"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">get</span>(<span class="dv">1</span>));</span>
<span id="cb31-36"><a href="#cb31-36"></a></span>
<span id="cb31-37"><a href="#cb31-37"></a>    <span class="co">// teste 5</span></span>
<span id="cb31-38"><a href="#cb31-38"></a>    s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-39"><a href="#cb31-39"></a>    s.<span class="fu">add</span>(<span class="dv">1</span>);</span>
<span id="cb31-40"><a href="#cb31-40"></a>    s.<span class="fu">remove</span>(<span class="dv">0</span>);</span>
<span id="cb31-41"><a href="#cb31-41"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">size</span>());</span>
<span id="cb31-42"><a href="#cb31-42"></a>    <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(s.<span class="fu">isEmpty</span>());</span>
<span id="cb31-43"><a href="#cb31-43"></a></span>
<span id="cb31-44"><a href="#cb31-44"></a>    <span class="co">// teste 6</span></span>
<span id="cb31-45"><a href="#cb31-45"></a>    <span class="kw">try</span> {</span>
<span id="cb31-46"><a href="#cb31-46"></a>      s = <span class="kw">new</span> <span class="bu">ArrayList</span>&lt;<span class="bu">Integer</span>&gt;();</span>
<span id="cb31-47"><a href="#cb31-47"></a>      s.<span class="fu">add</span>(<span class="dv">1</span>);</span>
<span id="cb31-48"><a href="#cb31-48"></a>      s.<span class="fu">add</span>(<span class="dv">2</span>);</span>
<span id="cb31-49"><a href="#cb31-49"></a>      s.<span class="fu">remove</span>(<span class="dv">2</span>);        </span>
<span id="cb31-50"><a href="#cb31-50"></a>    }</span>
<span id="cb31-51"><a href="#cb31-51"></a></span>
<span id="cb31-52"><a href="#cb31-52"></a>    <span class="kw">catch</span> (<span class="bu">IndexOutOfBoundsException</span> e) {</span>
<span id="cb31-53"><a href="#cb31-53"></a>      <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;IndexOutOfBound&quot;</span>);</span>
<span id="cb31-54"><a href="#cb31-54"></a>    }</span>
<span id="cb31-55"><a href="#cb31-55"></a></span>
<span id="cb31-56"><a href="#cb31-56"></a>  }</span>
<span id="cb31-57"><a href="#cb31-57"></a></span>
<span id="cb31-58"><a href="#cb31-58"></a>}</span></code></pre></div>
<p>6. Seja a seguinte função. Observe que ela possui quatro comandos, sendo dois deles <code>if</code>. Logo, esses dois <code>ifs</code> geram quatro branches:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb32-1"><a href="#cb32-1"></a><span class="dt">void</span> <span class="fu">f</span>(<span class="dt">int</span> x, <span class="dt">int</span> y) {</span>
<span id="cb32-2"><a href="#cb32-2"></a>  <span class="kw">if</span> (x &gt; <span class="dv">0</span>) {</span>
<span id="cb32-3"><a href="#cb32-3"></a>     x = <span class="dv">2</span> * x;</span>
<span id="cb32-4"><a href="#cb32-4"></a>     <span class="kw">if</span> (y &gt; <span class="dv">0</span>) {</span>
<span id="cb32-5"><a href="#cb32-5"></a>        y = <span class="dv">2</span> * y;</span>
<span id="cb32-6"><a href="#cb32-6"></a>     }</span>
<span id="cb32-7"><a href="#cb32-7"></a>   }</span>
<span id="cb32-8"><a href="#cb32-8"></a>}</span></code></pre></div>
<p>Supondo o código acima, preencha a próxima tabela, com os valores da cobertura de comandos e cobertura de branches obtidos com os testes especificados na primeira coluna (ou seja, a primeira coluna define as chamadas da função <code>f</code> que o teste realiza).</p>
<table>
<thead>
<tr class="header">
<th>Chamada feita pelo teste</th>
<th>Cobertura de comandos</th>
<th>Cobertura de branches</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>f(0,0)</td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>f(1,1)</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>f(0,0) e f(1,1)</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>7. Suponha o seguinte requisito: alunos recebem conceito A em uma disciplina se tiverem nota maior ou igual a 90. Seja então a seguinte função que implementa esse requisito:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb33-1"><a href="#cb33-1"></a><span class="dt">boolean</span> <span class="fu">isConceitoA</span>(<span class="dt">int</span> nota) {</span>
<span id="cb33-2"><a href="#cb33-2"></a>  <span class="kw">if</span> (nota &gt; <span class="dv">90</span>)</span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="kw">return</span> <span class="kw">true</span>;</span>
<span id="cb33-4"><a href="#cb33-4"></a>  <span class="kw">else</span> <span class="kw">return</span> <span class="kw">false</span>;</span>
<span id="cb33-5"><a href="#cb33-5"></a>}</span></code></pre></div>
<p>O código dessa função possui três comandos, sendo um deles um <code>if</code>; logo, ela possui dois branches.</p>
<p>Responda agora às seguintes perguntas.</p>
<ol type="a">
<li><p>A implementação dessa função possui um bug? Se sim, quando esse bug resulta em falha?</p></li>
<li><p>Suponha que essa função — exatamente como ela está implementada — seja testada com duas notas: 85 e 95. Qual a cobertura de comandos desse teste? E a cobertura de branches?</p></li>
<li><p>Seja a seguinte afirmação: se um programa possui 100% de cobertura de testes, em nível de comandos, ele está livre de bugs. Ela é verdadeira ou falsa? Justifique.</p></li>
</ol>
<p>8. Complete os comandos <code>assert</code> nos trechos indicados.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">test1</span>() {</span>
<span id="cb34-2"><a href="#cb34-2"></a>   <span class="bu">LinkedList</span> list = <span class="fu">mock</span>(<span class="bu">LinkedList</span>.<span class="fu">class</span>);</span>
<span id="cb34-3"><a href="#cb34-3"></a>   <span class="fu">when</span>(list.<span class="fu">size</span>()).<span class="fu">thenReturn</span>(<span class="dv">10</span>);</span>
<span id="cb34-4"><a href="#cb34-4"></a>   <span class="fu">assertEquals</span>(___________, ___________);</span>
<span id="cb34-5"><a href="#cb34-5"></a>}</span>
<span id="cb34-6"><a href="#cb34-6"></a></span>
<span id="cb34-7"><a href="#cb34-7"></a><span class="kw">public</span> <span class="dt">void</span> <span class="fu">test2</span>() {</span>
<span id="cb34-8"><a href="#cb34-8"></a>   <span class="bu">LinkedList</span> list = <span class="fu">mock</span>(<span class="bu">LinkedList</span>.<span class="fu">class</span>);</span>
<span id="cb34-9"><a href="#cb34-9"></a>   <span class="fu">when</span>(list.<span class="fu">get</span>(<span class="dv">0</span>)).<span class="fu">thenReturn</span>(<span class="st">&quot;Engenharia&quot;</span>);</span>
<span id="cb34-10"><a href="#cb34-10"></a>   <span class="fu">when</span>(list.<span class="fu">get</span>(<span class="dv">1</span>)).<span class="fu">thenReturn</span>(<span class="st">&quot;Software&quot;</span>);</span>
<span id="cb34-11"><a href="#cb34-11"></a>   <span class="bu">String</span> result = list.<span class="fu">get</span>(<span class="dv">0</span>) + <span class="st">&quot; &quot;</span> + list.<span class="fu">get</span>(<span class="dv">1</span>);</span>
<span id="cb34-12"><a href="#cb34-12"></a>   <span class="fu">assertEquals</span>(___________, ___________);</span>
<span id="cb34-13"><a href="#cb34-13"></a>}</span></code></pre></div>
<p>9. Suponha duas unidades de código A e B, sendo que A depende de B. Para permitir o teste de unidade de A foi criado um mock para B, chamado B'. O teste de unidade de A está passando. Porém, ao fazer o teste de integração com A e B, ele falha. Descreva um cenário mais real, onde A, B, e B' sejam classes reais, com métodos reais, que realizam funções reais, etc. O cenário proposto deve incluir um bug associado ao mock B'. Ou seja, B' esconde um bug, que só vai aparecer no teste de integração. Dizendo de outra maneira, B' não simula precisamente o comportamento de B; quando B' é removido, no teste de integração, surge então um bug.</p>
</div>
</div>
</div>

<footer>
ASERG/DCC/UFMG. Direitos autorais reservados. Versão para uso pessoal.
Para reportar quaisquer erros, incluindo pequenos erros de ortografia, use este <a href="https://forms.gle/KbzvMx5RLnqPR7uq7">formulário</a>.
</footer>
</body>
</html>
